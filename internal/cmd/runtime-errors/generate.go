// Copyright (c) 2018 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"

	"gate.computer/gate/internal/error/runtime"
)

const (
	maxErrors = 100
)

var subsystems = map[string][2]string{
	"CONT":     {"Executor", "runtime container"},
	"EXEC":     {"Executor", "runtime executor"},
	"EXECHILD": {"Process", "process executor"},
	"LOAD":     {"Process", "process loader"},
	"REAP":     {"Executor", "runtime reaper"},
	"RT":       {"Process", "process runtime"},
	"SEND":     {"Executor", "runtime executor"},
	"SENTINEL": {"Process", "sentinel process"},
}

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s target-filename source-filename...\n", flag.CommandLine.Name())
		flag.PrintDefaults()
	}
	flag.Parse()
	if flag.NArg() < 2 {
		flag.Usage()
		os.Exit(2)
	}
	outputname := flag.Arg(0)
	inputnames := flag.Args()[1:]

	errors := map[string][]runtime.Error{
		"Executor": runtime.ExecutorErrors[:],
		"Process":  runtime.ProcessErrors[:],
	}

	sort.Strings(inputnames)
	for _, filename := range inputnames {
		parseFile(filename, errors)
	}

	var cats []string

	for cat, es := range errors {
		if len(es) > maxErrors {
			log.Fatalf("too many %s errors: %d", cat, len(es))
		}

		cats = append(cats, cat)
	}

	sort.Strings(cats)

	var uninit bool

	b := bytes.NewBuffer(nil)

	fmt.Fprintln(b, "// Code generated by internal/cmd/runtime-errors.  You can edit it a little bit.")
	fmt.Fprintln(b)
	fmt.Fprintln(b, "package runtime")

	for _, cat := range cats {
		fmt.Fprintln(b)
		fmt.Fprintln(b, "const (")

		for i, e := range errors[cat] {
			if e.Define != "" {
				fmt.Fprintf(b, "%s = %d\n", e.Define, i)
			}
		}

		fmt.Fprintln(b, ")")
	}

	fmt.Fprintln(b)

	for _, cat := range cats {
		es := errors[cat]

		fmt.Fprintf(b, "var %sErrors = [%d]Error{\n", cat, len(es))

		for i, e := range es {
			if e.Define != "" {
				fmt.Fprintf(b, "%d: {%q, %q, %q},\n", i, e.Define, e.Subsys, e.Text)

				if strings.TrimSpace(e.Text) == "" {
					uninit = true
				}
			}
		}

		fmt.Fprintln(b, "}")
		fmt.Fprintln(b)
	}

	if uninit {
		fmt.Fprintln(b, "var ErrorsInitialized = false")
	} else {
		fmt.Fprintln(b, "var ErrorsInitialized struct{}")
	}

	f, err := os.Create("runtime/include/errors.h")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by internal/cmd/runtime-errors, DO NOT EDIT!")

	for _, cat := range cats {
		es := errors[cat]

		fmt.Fprintln(f)
		fmt.Fprintln(f, "//", cat)

		for i, e := range es {
			if e.Define != "" {
				fmt.Fprintf(f, "#define %s %d\n", e.Define, i)
			}
		}
	}

	if err := ioutil.WriteFile(outputname, b.Bytes(), 0644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

var re = regexp.MustCompile("ERR_[A-Z0-9]+_[A-Z0-9_]+")

func parseFile(filename string, errors map[string][]runtime.Error) {
	f, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	data, err := ioutil.ReadAll(f)
	if err != nil {
		log.Fatal(err)
	}

	for _, match := range re.FindAll(data, -1) {
		s := string(match)

		for _, es := range errors {
			for _, e := range es {
				if e.Define == s {
					goto found
				}
			}
		}

		{
			tokens := strings.Split(s, "_")

			pair, found := subsystems[tokens[1]]
			if !found {
				log.Fatal("Unknown subsystem: ", s)
			}

			defCat := pair[0]
			subsys := pair[1]

			errors[defCat] = append(errors[defCat], runtime.Error{
				Define: s,
				Subsys: subsys,
			})
		}

	found:
	}
}
