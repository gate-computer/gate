// Copyright (c) 2018 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/tsavola/gate/internal/error/runtime"
)

const (
	maxErrors = 100
)

var subsystems = map[string][2]string{
	"CONT":     {"Executor", "runtime container"},
	"EXEC":     {"Executor", "runtime executor"},
	"EXECHILD": {"Process", "process executor"},
	"LOAD":     {"Process", "process loader"},
	"REAP":     {"Executor", "runtime reaper"},
	"RT":       {"Process", "process runtime"},
	"SEND":     {"Executor", "runtime executor"},
	"SENTINEL": {"Process", "sentinel process"},
}

func main() {
	filenames := os.Args[1:]
	sort.Strings(filenames)

	errors := map[string][]runtime.Error{
		"Executor": runtime.ExecutorErrors[:],
		"Process":  runtime.ProcessErrors[:],
	}

	for _, filename := range filenames {
		parseFile(filename, errors)
	}

	var cats []string

	for cat, es := range errors {
		if len(es) > maxErrors {
			log.Fatalf("too many %s errors: %d", cat, len(es))
		}

		cats = append(cats, cat)
	}

	sort.Strings(cats)

	var uninit bool

	fmt.Println("// Code generated by internal/cmd/runtime-errors.  You can edit it a little bit.")
	fmt.Println()
	fmt.Println("package runtime")
	fmt.Println()

	for _, cat := range cats {
		es := errors[cat]

		fmt.Printf("var %sErrors = [%d]Error{\n", cat, len(es))

		for i, e := range es {
			if e.Define != "" {
				fmt.Printf("%d: {%q, %q, %q},\n", i, e.Define, e.Subsys, e.Text)

				if strings.TrimSpace(e.Text) == "" {
					uninit = true
				}
			}
		}

		fmt.Println("}")
		fmt.Println()
	}

	if uninit {
		fmt.Println("var ErrorsInitialized = false")
	} else {
		fmt.Println("var ErrorsInitialized struct{}")
	}

	f, err := os.Create("runtime/include/errors.h")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by internal/runtime-err-gen.  DO NOT EDIT.")

	for _, cat := range cats {
		es := errors[cat]

		fmt.Fprintln(f)
		fmt.Fprintln(f, "//", cat)

		for i, e := range es {
			if e.Define != "" {
				fmt.Fprintf(f, "#define %s %d\n", e.Define, i)
			}
		}
	}
}

var re = regexp.MustCompile("ERR_[A-Z0-9]+_[A-Z0-9_]+")

func parseFile(filename string, errors map[string][]runtime.Error) {
	f, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	data, err := ioutil.ReadAll(f)
	if err != nil {
		log.Fatal(err)
	}

	for _, match := range re.FindAll(data, -1) {
		s := string(match)

		for _, es := range errors {
			for _, e := range es {
				if e.Define == s {
					goto found
				}
			}
		}

		{
			tokens := strings.Split(s, "_")

			pair, found := subsystems[tokens[1]]
			if !found {
				log.Fatal("Unknown subsystem: ", s)
			}

			defCat := pair[0]
			subsys := pair[1]

			errors[defCat] = append(errors[defCat], runtime.Error{
				Define: s,
				Subsys: subsys,
			})
		}

	found:
	}
}
