// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOCALHOST_LOCALHOST_FLAT_H_
#define FLATBUFFERS_GENERATED_LOCALHOST_LOCALHOST_FLAT_H_

#pragma clang system_header


#include "flatbuffers/flatbuffers.h"

namespace localhost {
namespace flat {

struct HTTPRequest;
struct HTTPRequestT;

struct HTTPResponse;
struct HTTPResponseT;

struct Call;
struct CallT;

enum Function {
  Function_NONE = 0,
  Function_HTTPRequest = 1,
  Function_MIN = Function_NONE,
  Function_MAX = Function_HTTPRequest
};

inline const Function (&EnumValuesFunction())[2] {
  static const Function values[] = {
    Function_NONE,
    Function_HTTPRequest
  };
  return values;
}

inline const char * const *EnumNamesFunction() {
  static const char * const names[] = {
    "NONE",
    "HTTPRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameFunction(Function e) {
  if (e < Function_NONE || e > Function_HTTPRequest) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFunction()[index];
}

template<typename T> struct FunctionTraits {
  static const Function enum_value = Function_NONE;
};

template<> struct FunctionTraits<HTTPRequest> {
  static const Function enum_value = Function_HTTPRequest;
};

struct FunctionUnion {
  Function type;
  void *value;

  FunctionUnion() : type(Function_NONE), value(nullptr) {}
  FunctionUnion(FunctionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Function_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  FunctionUnion(const FunctionUnion &) FLATBUFFERS_NOEXCEPT;
  FunctionUnion &operator=(const FunctionUnion &u) FLATBUFFERS_NOEXCEPT
    { FunctionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  FunctionUnion &operator=(FunctionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~FunctionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = FunctionTraits<typename RT::TableType>::enum_value;
    if (type != Function_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Function type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  HTTPRequestT *AsHTTPRequest() {
    return type == Function_HTTPRequest ?
      reinterpret_cast<HTTPRequestT *>(value) : nullptr;
  }
  const HTTPRequestT *AsHTTPRequest() const {
    return type == Function_HTTPRequest ?
      reinterpret_cast<const HTTPRequestT *>(value) : nullptr;
  }
};

bool VerifyFunction(flatbuffers::Verifier &verifier, const void *obj, Function type);
bool VerifyFunctionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct HTTPRequestT : public flatbuffers::NativeTable {
  typedef HTTPRequest TableType;
  std::string method;
  std::string uri;
  std::string content_type;
  std::vector<uint8_t> body;
  HTTPRequestT() {
  }
};

struct HTTPRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HTTPRequestT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_URI = 6,
    VT_CONTENT_TYPE = 8,
    VT_BODY = 10
  };
  const flatbuffers::String * _Nullable method() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD);
  }
  const flatbuffers::String * _Nullable uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  const flatbuffers::String * _Nullable content_type() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT_TYPE);
  }
  const flatbuffers::Vector<uint8_t> * _Nullable body() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyString(method()) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.VerifyString(uri()) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyString(content_type()) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.VerifyVector(body()) &&
           verifier.EndTable();
  }
  HTTPRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HTTPRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HTTPRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HTTPRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HTTPRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(flatbuffers::Offset<flatbuffers::String> method) {
    fbb_.AddOffset(HTTPRequest::VT_METHOD, method);
  }
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(HTTPRequest::VT_URI, uri);
  }
  void add_content_type(flatbuffers::Offset<flatbuffers::String> content_type) {
    fbb_.AddOffset(HTTPRequest::VT_CONTENT_TYPE, content_type);
  }
  void add_body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body) {
    fbb_.AddOffset(HTTPRequest::VT_BODY, body);
  }
  explicit HTTPRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HTTPRequestBuilder &operator=(const HTTPRequestBuilder &);
  flatbuffers::Offset<HTTPRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HTTPRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HTTPRequest> CreateHTTPRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> method = 0,
    flatbuffers::Offset<flatbuffers::String> uri = 0,
    flatbuffers::Offset<flatbuffers::String> content_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body = 0) {
  HTTPRequestBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_content_type(content_type);
  builder_.add_uri(uri);
  builder_.add_method(method);
  return builder_.Finish();
}

inline flatbuffers::Offset<HTTPRequest> CreateHTTPRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *method = nullptr,
    const char *uri = nullptr,
    const char *content_type = nullptr,
    const std::vector<uint8_t> *body = nullptr) {
  auto method__ = method ? _fbb.CreateString(method) : 0;
  auto uri__ = uri ? _fbb.CreateString(uri) : 0;
  auto content_type__ = content_type ? _fbb.CreateString(content_type) : 0;
  auto body__ = body ? _fbb.CreateVector<uint8_t>(*body) : 0;
  return localhost::flat::CreateHTTPRequest(
      _fbb,
      method__,
      uri__,
      content_type__,
      body__);
}

flatbuffers::Offset<HTTPRequest> CreateHTTPRequest(flatbuffers::FlatBufferBuilder &_fbb, const HTTPRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HTTPResponseT : public flatbuffers::NativeTable {
  typedef HTTPResponse TableType;
  int32_t status_code;
  int64_t content_length;
  std::string content_type;
  std::vector<uint8_t> body;
  int32_t body_stream_id;
  HTTPResponseT()
      : status_code(0),
        content_length(0),
        body_stream_id(0) {
  }
};

struct HTTPResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HTTPResponseT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS_CODE = 4,
    VT_CONTENT_LENGTH = 6,
    VT_CONTENT_TYPE = 8,
    VT_BODY = 10,
    VT_BODY_STREAM_ID = 12
  };
  int32_t status_code() const {
    return GetField<int32_t>(VT_STATUS_CODE, 0);
  }
  int64_t content_length() const {
    return GetField<int64_t>(VT_CONTENT_LENGTH, 0);
  }
  const flatbuffers::String * _Nullable content_type() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT_TYPE);
  }
  const flatbuffers::Vector<uint8_t> * _Nullable body() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BODY);
  }
  int32_t body_stream_id() const {
    return GetField<int32_t>(VT_BODY_STREAM_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS_CODE) &&
           VerifyField<int64_t>(verifier, VT_CONTENT_LENGTH) &&
           VerifyOffset(verifier, VT_CONTENT_TYPE) &&
           verifier.VerifyString(content_type()) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.VerifyVector(body()) &&
           VerifyField<int32_t>(verifier, VT_BODY_STREAM_ID) &&
           verifier.EndTable();
  }
  HTTPResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HTTPResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HTTPResponse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HTTPResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HTTPResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status_code(int32_t status_code) {
    fbb_.AddElement<int32_t>(HTTPResponse::VT_STATUS_CODE, status_code, 0);
  }
  void add_content_length(int64_t content_length) {
    fbb_.AddElement<int64_t>(HTTPResponse::VT_CONTENT_LENGTH, content_length, 0);
  }
  void add_content_type(flatbuffers::Offset<flatbuffers::String> content_type) {
    fbb_.AddOffset(HTTPResponse::VT_CONTENT_TYPE, content_type);
  }
  void add_body(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body) {
    fbb_.AddOffset(HTTPResponse::VT_BODY, body);
  }
  void add_body_stream_id(int32_t body_stream_id) {
    fbb_.AddElement<int32_t>(HTTPResponse::VT_BODY_STREAM_ID, body_stream_id, 0);
  }
  explicit HTTPResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HTTPResponseBuilder &operator=(const HTTPResponseBuilder &);
  flatbuffers::Offset<HTTPResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HTTPResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<HTTPResponse> CreateHTTPResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status_code = 0,
    int64_t content_length = 0,
    flatbuffers::Offset<flatbuffers::String> content_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> body = 0,
    int32_t body_stream_id = 0) {
  HTTPResponseBuilder builder_(_fbb);
  builder_.add_content_length(content_length);
  builder_.add_body_stream_id(body_stream_id);
  builder_.add_body(body);
  builder_.add_content_type(content_type);
  builder_.add_status_code(status_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<HTTPResponse> CreateHTTPResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status_code = 0,
    int64_t content_length = 0,
    const char *content_type = nullptr,
    const std::vector<uint8_t> *body = nullptr,
    int32_t body_stream_id = 0) {
  auto content_type__ = content_type ? _fbb.CreateString(content_type) : 0;
  auto body__ = body ? _fbb.CreateVector<uint8_t>(*body) : 0;
  return localhost::flat::CreateHTTPResponse(
      _fbb,
      status_code,
      content_length,
      content_type__,
      body__,
      body_stream_id);
}

flatbuffers::Offset<HTTPResponse> CreateHTTPResponse(flatbuffers::FlatBufferBuilder &_fbb, const HTTPResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallT : public flatbuffers::NativeTable {
  typedef Call TableType;
  FunctionUnion function;
  CallT() {
  }
};

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION_TYPE = 4,
    VT_FUNCTION = 6
  };
  Function function_type() const {
    return static_cast<Function>(GetField<uint8_t>(VT_FUNCTION_TYPE, 0));
  }
  const void * _Nullable function() const {
    return GetPointer<const void *>(VT_FUNCTION);
  }
  template<typename T> const T * _Nullable function_as() const;
  const HTTPRequest * _Nullable function_as_HTTPRequest() const {
    return function_type() == Function_HTTPRequest ? static_cast<const HTTPRequest *>(function()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FUNCTION_TYPE) &&
           VerifyOffset(verifier, VT_FUNCTION) &&
           VerifyFunction(verifier, function(), function_type()) &&
           verifier.EndTable();
  }
  CallT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Call> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const HTTPRequest *Call::function_as<HTTPRequest>() const {
  return function_as_HTTPRequest();
}

struct CallBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function_type(Function function_type) {
    fbb_.AddElement<uint8_t>(Call::VT_FUNCTION_TYPE, static_cast<uint8_t>(function_type), 0);
  }
  void add_function(flatbuffers::Offset<void> function) {
    fbb_.AddOffset(Call::VT_FUNCTION, function);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallBuilder &operator=(const CallBuilder &);
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    Function function_type = Function_NONE,
    flatbuffers::Offset<void> function = 0) {
  CallBuilder builder_(_fbb);
  builder_.add_function(function);
  builder_.add_function_type(function_type);
  return builder_.Finish();
}

flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HTTPRequestT *HTTPRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HTTPRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HTTPRequest::UnPackTo(HTTPRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); if (_e) _o->method = _e->str(); };
  { auto _e = uri(); if (_e) _o->uri = _e->str(); };
  { auto _e = content_type(); if (_e) _o->content_type = _e->str(); };
  { auto _e = body(); if (_e) { _o->body.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->body[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<HTTPRequest> HTTPRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HTTPRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHTTPRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HTTPRequest> CreateHTTPRequest(flatbuffers::FlatBufferBuilder &_fbb, const HTTPRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HTTPRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method.empty() ? 0 : _fbb.CreateString(_o->method);
  auto _uri = _o->uri.empty() ? 0 : _fbb.CreateString(_o->uri);
  auto _content_type = _o->content_type.empty() ? 0 : _fbb.CreateString(_o->content_type);
  auto _body = _o->body.size() ? _fbb.CreateVector(_o->body) : 0;
  return localhost::flat::CreateHTTPRequest(
      _fbb,
      _method,
      _uri,
      _content_type,
      _body);
}

inline HTTPResponseT *HTTPResponse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HTTPResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HTTPResponse::UnPackTo(HTTPResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status_code(); _o->status_code = _e; };
  { auto _e = content_length(); _o->content_length = _e; };
  { auto _e = content_type(); if (_e) _o->content_type = _e->str(); };
  { auto _e = body(); if (_e) { _o->body.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->body[_i] = _e->Get(_i); } } };
  { auto _e = body_stream_id(); _o->body_stream_id = _e; };
}

inline flatbuffers::Offset<HTTPResponse> HTTPResponse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HTTPResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHTTPResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HTTPResponse> CreateHTTPResponse(flatbuffers::FlatBufferBuilder &_fbb, const HTTPResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HTTPResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status_code = _o->status_code;
  auto _content_length = _o->content_length;
  auto _content_type = _o->content_type.empty() ? 0 : _fbb.CreateString(_o->content_type);
  auto _body = _o->body.size() ? _fbb.CreateVector(_o->body) : 0;
  auto _body_stream_id = _o->body_stream_id;
  return localhost::flat::CreateHTTPResponse(
      _fbb,
      _status_code,
      _content_length,
      _content_type,
      _body,
      _body_stream_id);
}

inline CallT *Call::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CallT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Call::UnPackTo(CallT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = function_type(); _o->function.type = _e; };
  { auto _e = function(); if (_e) _o->function.value = FunctionUnion::UnPack(_e, function_type(), _resolver); };
}

inline flatbuffers::Offset<Call> Call::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCall(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Call> CreateCall(flatbuffers::FlatBufferBuilder &_fbb, const CallT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _function_type = _o->function.type;
  auto _function = _o->function.Pack(_fbb);
  return localhost::flat::CreateCall(
      _fbb,
      _function_type,
      _function);
}

inline bool VerifyFunction(flatbuffers::Verifier &verifier, const void *obj, Function type) {
  switch (type) {
    case Function_NONE: {
      return true;
    }
    case Function_HTTPRequest: {
      auto ptr = reinterpret_cast<const HTTPRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyFunctionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFunction(
        verifier,  values->Get(i), types->GetEnum<Function>(i))) {
      return false;
    }
  }
  return true;
}

inline void *FunctionUnion::UnPack(const void *obj, Function type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Function_HTTPRequest: {
      auto ptr = reinterpret_cast<const HTTPRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> FunctionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Function_HTTPRequest: {
      auto ptr = reinterpret_cast<const HTTPRequestT *>(value);
      return CreateHTTPRequest(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline FunctionUnion::FunctionUnion(const FunctionUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Function_HTTPRequest: {
      value = new HTTPRequestT(*reinterpret_cast<HTTPRequestT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void FunctionUnion::Reset() {
  switch (type) {
    case Function_HTTPRequest: {
      auto ptr = reinterpret_cast<HTTPRequestT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Function_NONE;
}

}  // namespace flat
}  // namespace localhost

#endif  // FLATBUFFERS_GENERATED_LOCALHOST_LOCALHOST_FLAT_H_
