// Copyright (c) 2019 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The memory access instructions generated by wag use a zero-extended register
// as variable offset, with a 31-bit constant offset.
#define MEMORY_ADDRESS_RANGE (0x100000000ULL + 0x80000000ULL)

namespace {

bool strcmp_clock_gettime(char const* name)
{
	if (strlen(name) != 20)
		return false;

	if (reinterpret_cast<uint64_t const*>(name)[0] != 0x635f6f7364765f5fULL) // Little-endian "__vdso_c"
		return false;

	if (reinterpret_cast<uint64_t const*>(name)[1] != 0x7465675f6b636f6cULL) // Little-endian "lock_get"
		return false;

	if (reinterpret_cast<uint32_t const*>(name)[4] != 0x656d6974UL) // Little-endian "time"
		return false;

	return true;
}

void enter(
	void* stack_ptr,
	uintptr_t stack_limit,
	uint64_t start,
	uintptr_t loader_stack,
	size_t loader_stack_size,
	uint64_t signal_handler,
	uint64_t signal_restorer,
	uintptr_t init_routine)
{
	register auto rax asm("rax") = stack_ptr;
	register auto rbx asm("rbx") = stack_limit;
	register auto rbp asm("rbp") = start;
	register auto rsi asm("rsi") = loader_stack_size; // munmap length
	register auto rdi asm("rdi") = loader_stack;      // munmap addr
	register auto r9 asm("r9") = signal_handler;
	register auto r10 asm("r10") = signal_restorer;
	register auto r13 asm("r13") = SIGACTION_FLAGS;
	register auto r15 asm("r15") = init_routine;

	// clang-format off

	asm volatile(
		// Replace stack.

		"mov  %%rax, %%rsp                          \n"

		// Unmap old stack (ASLR breaks this).

		"mov  $" xstr(SYS_munmap) ", %%eax          \n"
		"syscall                                    \n"
		"mov  $" xstr(ERR_LOAD_MUNMAP_STACK) ", %%edi \n"
		"test %%eax, %%eax                          \n"
		"jne  sys_exit                              \n"

		// Build sigaction structure on rt function stack.

		"mov  %%rsp, %%rsi                          \n"
		"sub  $32, %%rsi                            \n" // sigaction act
		"mov  %%r9, 0(%%rsi)                        \n" // sa_handler
		"mov  %%r13, 8(%%rsi)                       \n" // sa_flags
		"mov  %%r10, 16(%%rsi)                      \n" // sa_restorer
		"movq $0, 24(%%rsi)                         \n" // sa_mask

		"xor  %%edx, %%edx                          \n" // sigaction oldact
		"mov  $8, %%r10d                            \n" // sigaction mask size

		// Segmentation fault signal handler.

		"mov  $" xstr(SIGSEGV) ", %%edi             \n"
		"mov  $" xstr(SYS_rt_sigaction) ", %%eax    \n"
		"syscall                                    \n"
		"mov  $" xstr(ERR_LOAD_SIGACTION) ", %%edi  \n"
		"test %%eax, %%eax                          \n"
		"jne  sys_exit                              \n"

		// Suspend signal handler.

		"mov  $" xstr(SIGXCPU) ", %%edi             \n"
		"mov  $" xstr(SYS_rt_sigaction) ", %%eax    \n"
		"syscall                                    \n"
		"mov  $" xstr(ERR_LOAD_SIGACTION) ", %%edi  \n"
		"test %%eax, %%eax                          \n"
		"jne  sys_exit                              \n"

		// Execute rt_start or rt_start_no_sandbox.

		"mov  %%rbp, %%r9                           \n"
		"jmp  trampoline                            \n"
		:
		: "r"(rax), "r"(rbx), "r"(rbp), "r"(rsi), "r"(rdi), "r"(r9), "r"(r10), "r"(r13), "r"(r15));

	// clang-format on

	__builtin_unreachable();
}

} // namespace
