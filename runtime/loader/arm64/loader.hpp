// Copyright (c) 2019 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The memory access instructions generated by wag use an unscaled,
// zero-extended register as offset.
#define MEMORY_ADDRESS_RANGE 0x100000000ULL

namespace runtime::loader {

bool strcmp_clock_gettime(char const* name)
{
	if (strlen(name) != 22)
		return false;

	if (reinterpret_cast<uint64_t const*>(name)[0] != 0x6c656e72656b5f5fULL) // Little-endian "__kernel"
		return false;

	if (reinterpret_cast<uint64_t const*>(name)[1] != 0x675f6b636f6c635fULL) // Little-endian "_clock_g"
		return false;

	if (reinterpret_cast<uint32_t const*>(name)[4] != 0x69747465UL) // Little-endian "etti"
		return false;

	if (reinterpret_cast<uint16_t const*>(name)[10] != 0x656d) // Little-endian "me"
		return false;

	return true;
}

NORETURN void enter_rt(void* stack_ptr, uintptr_t stack_limit)
{
	register auto r29 asm("r29") = stack_ptr;
	register auto sp asm("sp") = stack_limit - 256; // Signal stack pointer.

	asm volatile("b start_rt" :: "r"(r29), "r"(sp));
	__builtin_unreachable();
}

} // namespace runtime::loader
