// Copyright (c) 2019 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The memory access instructions generated by wag use an unscaled,
// zero-extended register as offset.
#define MEMORY_ADDRESS_RANGE 0x100000000ULL

namespace {

bool strcmp_clock_gettime(char const* name)
{
	if (strlen(name) != 22)
		return false;

	if (reinterpret_cast<uint64_t const*>(name)[0] != 0x6c656e72656b5f5fULL) // Little-endian "__kernel"
		return false;

	if (reinterpret_cast<uint64_t const*>(name)[1] != 0x675f6b636f6c635fULL) // Little-endian "_clock_g"
		return false;

	if (reinterpret_cast<uint32_t const*>(name)[4] != 0x69747465UL) // Little-endian "etti"
		return false;

	if (reinterpret_cast<uint16_t const*>(name)[10] != 0x656d) // Little-endian "me"
		return false;

	return true;
}

void enter(
	void* stack_ptr,
	uintptr_t stack_limit,
	uint64_t start,
	uintptr_t loader_stack,
	size_t loader_stack_size,
	uint64_t signal_handler,
	uint64_t signal_restorer,
	uintptr_t init_routine)
{
	uintptr_t link_ptr = 0;
	if ((uintptr_t(init_routine) & 0xff) == 0x20) { // Resume routine
		link_ptr = *reinterpret_cast<uintptr_t*>(stack_ptr);
		stack_ptr = reinterpret_cast<uintptr_t*>(stack_ptr) + 1;
	}

	register auto r0 asm("r0") = loader_stack;      // munmap addr
	register auto r1 asm("r1") = loader_stack_size; // munmap length
	register auto r4 asm("r4") = signal_handler;
	register auto r5 asm("r5") = SIGACTION_FLAGS;
	register auto r6 asm("r6") = signal_restorer;
	register auto r9 asm("r9") = start;
	register auto r27 asm("r27") = init_routine;
	register auto r28 asm("r28") = stack_limit;
	register auto r29 asm("r29") = stack_ptr;
	register auto r30 asm("r30") = link_ptr;

	// clang-format off

	asm volatile(
		// Replace stack.

		"sub  sp, x28, #256                      \n" // Signal stack pointer
		"lsr  x28, x28, #4                       \n" // Stack limit >> 4

		// Unmap old stack (ASLR breaks this).

		"mov  w8, " xstr(SYS_munmap) "           \n"
		"svc  #0                                 \n"
		"cmp  w0, #0                             \n"
		"mov  w0, #" xstr(ERR_LOAD_MUNMAP_STACK) "\n"
		"b.ne sys_exit                           \n"

		// Build sigaction structure on rt function stack.

		"mov  x1, sp                             \n" // sigaction act
		"str  x4, [x1, #0]                       \n" // sa_handler
		"str  x5, [x1, #8]                       \n" // sa_flags
		"str  x6, [x1, #16]                      \n" // sa_restorer
		"str  xzr, [x1, #24]                     \n" // sa_mask

		"mov  x2, #0                             \n" // sigaction oldact
		"mov  x3, #8                             \n" // sigaction mask size

		// Segmentation fault signal handler.

		"mov  w0, #" xstr(SIGSEGV) "             \n" // sigaction signum
		"mov  w8, #" xstr(SYS_rt_sigaction) "    \n"
		"svc  #0                                 \n"
		"cmp  w0, #0                             \n"
		"mov  w0, #" xstr(ERR_LOAD_SIGACTION) "  \n"
		"b.ne sys_exit                           \n"

		// Suspend signal handler.

		"mov  w0, #" xstr(SIGXCPU) "             \n" // sigaction signum
		"mov  w8, #" xstr(SYS_rt_sigaction) "    \n"
		"svc  #0                                 \n"
		"cmp  w0, #0                             \n"
		"mov  w0, #" xstr(ERR_LOAD_SIGACTION) "  \n"
		"b.ne sys_exit                           \n"

		// Execute rt_start or rt_start_no_sandbox.

		"b    trampoline                         \n"
		:
		: "r"(r0), "r"(r1), "r"(r4), "r"(r5), "r"(r6), "r"(r9), "r"(r27), "r"(r28), "r"(r29), "r"(r30));

	// clang-format on

	__builtin_unreachable();
}

} // namespace
