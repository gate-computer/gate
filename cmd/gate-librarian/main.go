// Copyright (c) 2021 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"hash/crc64"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"regexp"
	"strings"

	"gate.computer/wag/compile"
	"gate.computer/wag/section"
)

const usage = `Usage: %s [options] filename [command...]

WebAssembly module is read from stdin, or from the stdout of command.
WebAssembly or Go code (depending on options) is written to filename.

Options:
`

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), usage, flag.CommandLine.Name())
		flag.PrintDefaults()
	}

	objdump := os.Getenv("WASM_OBJDUMP")
	if objdump == "" {
		objdump = "wasm-objdump"
	}

	var (
		gopkg   string
		verbose bool
	)

	flag.BoolVar(&verbose, "v", verbose, "don't be quiet")
	flag.StringVar(&gopkg, "go", gopkg, "generate Go code for given package")
	flag.StringVar(&objdump, "objdump", objdump, "wasm-objdump command to use")
	flag.Parse()

	if flag.NArg() == 0 {
		flag.Usage()
		os.Exit(2)
	}
	var (
		filename = flag.Arg(0)
		command  = flag.Args()[1:]
	)

	if err := Main(filename, objdump, gopkg, verbose, command); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func Main(filename, objdump, gopkg string, verbose bool, command []string) error {
	var data []byte

	if len(command) > 0 {
		cmd := exec.Command(command[0], command[1:]...)
		cmd.Stderr = os.Stderr
		b, err := cmd.Output()
		if err != nil {
			return err
		}
		data = b
	} else {
		b, err := ioutil.ReadAll(os.Stdin)
		if err != nil {
			return err
		}
		data = b
	}

	f, err := ioutil.TempFile("", "*.wasm")
	if err != nil {
		return err
	}
	defer os.Remove(f.Name())
	if _, err := f.Write(data); err != nil {
		return err
	}
	f.Close()

	cmd := exec.Command(objdump, "-d", f.Name())
	cmd.Stderr = os.Stderr
	dump, err := cmd.Output()
	if err != nil {
		return err
	}

	for _, line := range strings.Split(string(dump), "\n") {
		matched, err := regexp.MatchString(`(^\w+ func|\scall \d+ <rt_\w+>)`, line)
		if err != nil {
			return err
		}
		if matched {
			if verbose {
				fmt.Println("", line)
			}
			continue
		}

		matched, err = regexp.MatchString(`(^Data|\scall|\sglobal|\smemory\.grow)`, line)
		if err != nil {
			return err
		}
		if matched {
			if verbose {
				fmt.Println(line)
			}
			return errors.New("WebAssembly module is not a suitable library")
		}
	}

	sections := section.MakeMap()
	config := compile.ModuleConfig{
		Config: compile.Config{
			SectionMapper: sections.Mapper(),
		},
	}
	if _, err := compile.LoadInitialSections(&config, bytes.NewReader(data)); err != nil {
		return err
	}

	b := new(bytes.Buffer)
	r := bytes.NewReader(data)

	if _, err := io.CopyN(b, r, sections.Sections[section.Type].Offset); err != nil {
		return err
	}
	librarySections := map[section.ID]bool{
		section.Type:     true,
		section.Import:   true,
		section.Function: true,
		section.Memory:   true,
		section.Export:   true,
		section.Code:     true,
	}
	for id := section.Type; id <= section.Code; id++ {
		w := ioutil.Discard
		if librarySections[id] {
			w = b
		}
		if _, err := section.CopyStandardSection(w, r, id, nil); err != nil {
			return err
		}
	}

	data = b.Bytes()

	if gopkg != "" {
		b := bytes.NewBuffer(nil)
		checksum := crc64.Checksum(data, crc64.MakeTable(crc64.ECMA))

		fmt.Fprintln(b, "// Code generated by gate-librarian, DO NOT EDIT!")
		fmt.Fprintln(b)
		fmt.Fprintf(b, "package %s\n", gopkg)
		fmt.Fprintln(b)
		fmt.Fprintf(b, "const libraryChecksum uint64 = 0x%016x\n", checksum)
		fmt.Fprintln(b)
		fmt.Fprint(b, "var libraryWASM = [...]byte{")
		for i, n := range data {
			if i%12 == 0 {
				fmt.Fprintf(b, "\n\t")
			} else {
				fmt.Fprintf(b, " ")
			}
			fmt.Fprintf(b, "0x%02x,", n)
		}
		fmt.Fprintln(b, "\n}")

		data = b.Bytes()
	}

	if err := ioutil.WriteFile(filename, data, 0644); err != nil {
		return err
	}

	return nil
}
