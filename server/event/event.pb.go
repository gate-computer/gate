// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/event/event.proto

package event // import "github.com/tsavola/gate/server/event"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import detail "github.com/tsavola/gate/server/detail"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	Type_FAIL_INTERNAL          Type = 0
	Type_FAIL_NETWORK           Type = 1
	Type_FAIL_PROTOCOL          Type = 2
	Type_FAIL_REQUEST           Type = 3
	Type_IFACE_ACCESS           Type = 4
	Type_MODULE_LIST            Type = 5
	Type_MODULE_UPLOAD_NEW      Type = 6
	Type_MODULE_UPLOAD_EXIST    Type = 7
	Type_MODULE_SOURCE_NEW      Type = 8
	Type_MODULE_SOURCE_EXIST    Type = 9
	Type_MODULE_DOWNLOAD        Type = 10
	Type_MODULE_UNREF           Type = 11
	Type_INSTANCE_LIST          Type = 12
	Type_INSTANCE_CREATE_STREAM Type = 13
	Type_INSTANCE_CREATE_LOCAL  Type = 14
	Type_INSTANCE_DELETE        Type = 15
	Type_INSTANCE_CONNECT       Type = 16
	Type_INSTANCE_DISCONNECT    Type = 17
	Type_INSTANCE_STATUS        Type = 18
	Type_INSTANCE_WAIT          Type = 19
	Type_INSTANCE_SUSPEND       Type = 20
	Type_INSTANCE_RESUME        Type = 21
	Type_INSTANCE_SNAPSHOT      Type = 22
)

var Type_name = map[int32]string{
	0:  "FAIL_INTERNAL",
	1:  "FAIL_NETWORK",
	2:  "FAIL_PROTOCOL",
	3:  "FAIL_REQUEST",
	4:  "IFACE_ACCESS",
	5:  "MODULE_LIST",
	6:  "MODULE_UPLOAD_NEW",
	7:  "MODULE_UPLOAD_EXIST",
	8:  "MODULE_SOURCE_NEW",
	9:  "MODULE_SOURCE_EXIST",
	10: "MODULE_DOWNLOAD",
	11: "MODULE_UNREF",
	12: "INSTANCE_LIST",
	13: "INSTANCE_CREATE_STREAM",
	14: "INSTANCE_CREATE_LOCAL",
	15: "INSTANCE_DELETE",
	16: "INSTANCE_CONNECT",
	17: "INSTANCE_DISCONNECT",
	18: "INSTANCE_STATUS",
	19: "INSTANCE_WAIT",
	20: "INSTANCE_SUSPEND",
	21: "INSTANCE_RESUME",
	22: "INSTANCE_SNAPSHOT",
}
var Type_value = map[string]int32{
	"FAIL_INTERNAL":          0,
	"FAIL_NETWORK":           1,
	"FAIL_PROTOCOL":          2,
	"FAIL_REQUEST":           3,
	"IFACE_ACCESS":           4,
	"MODULE_LIST":            5,
	"MODULE_UPLOAD_NEW":      6,
	"MODULE_UPLOAD_EXIST":    7,
	"MODULE_SOURCE_NEW":      8,
	"MODULE_SOURCE_EXIST":    9,
	"MODULE_DOWNLOAD":        10,
	"MODULE_UNREF":           11,
	"INSTANCE_LIST":          12,
	"INSTANCE_CREATE_STREAM": 13,
	"INSTANCE_CREATE_LOCAL":  14,
	"INSTANCE_DELETE":        15,
	"INSTANCE_CONNECT":       16,
	"INSTANCE_DISCONNECT":    17,
	"INSTANCE_STATUS":        18,
	"INSTANCE_WAIT":          19,
	"INSTANCE_SUSPEND":       20,
	"INSTANCE_RESUME":        21,
	"INSTANCE_SNAPSHOT":      22,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{0}
}

type FailRequest_Type int32

const (
	FailRequest_UNSPECIFIED          FailRequest_Type = 0
	FailRequest_PAYLOAD_ERROR        FailRequest_Type = 1
	FailRequest_PRINCIPAL_KEY_ERROR  FailRequest_Type = 2
	FailRequest_AUTH_MISSING         FailRequest_Type = 3
	FailRequest_AUTH_INVALID         FailRequest_Type = 4
	FailRequest_AUTH_EXPIRED         FailRequest_Type = 5
	FailRequest_AUTH_REUSED          FailRequest_Type = 6
	FailRequest_AUTH_DENIED          FailRequest_Type = 7
	FailRequest_RESOURCE_DENIED      FailRequest_Type = 8
	FailRequest_RESOURCE_LIMIT       FailRequest_Type = 9
	FailRequest_RATE_LIMIT           FailRequest_Type = 10
	FailRequest_MODULE_NOT_FOUND     FailRequest_Type = 11
	FailRequest_MODULE_HASH_MISMATCH FailRequest_Type = 12
	FailRequest_MODULE_ERROR         FailRequest_Type = 13
	FailRequest_FUNCTION_NOT_FOUND   FailRequest_Type = 14
	FailRequest_PROGRAM_ERROR        FailRequest_Type = 15
	FailRequest_INSTANCE_NOT_FOUND   FailRequest_Type = 16
	FailRequest_INSTANCE_ID_INVALID  FailRequest_Type = 17
	FailRequest_INSTANCE_ID_EXISTS   FailRequest_Type = 18
	FailRequest_INSTANCE_STATUS      FailRequest_Type = 19
	FailRequest_INSTANCE_NO_CONNECT  FailRequest_Type = 20
	FailRequest_INSTANCE_TRANSIENT   FailRequest_Type = 21
)

var FailRequest_Type_name = map[int32]string{
	0:  "UNSPECIFIED",
	1:  "PAYLOAD_ERROR",
	2:  "PRINCIPAL_KEY_ERROR",
	3:  "AUTH_MISSING",
	4:  "AUTH_INVALID",
	5:  "AUTH_EXPIRED",
	6:  "AUTH_REUSED",
	7:  "AUTH_DENIED",
	8:  "RESOURCE_DENIED",
	9:  "RESOURCE_LIMIT",
	10: "RATE_LIMIT",
	11: "MODULE_NOT_FOUND",
	12: "MODULE_HASH_MISMATCH",
	13: "MODULE_ERROR",
	14: "FUNCTION_NOT_FOUND",
	15: "PROGRAM_ERROR",
	16: "INSTANCE_NOT_FOUND",
	17: "INSTANCE_ID_INVALID",
	18: "INSTANCE_ID_EXISTS",
	19: "INSTANCE_STATUS",
	20: "INSTANCE_NO_CONNECT",
	21: "INSTANCE_TRANSIENT",
}
var FailRequest_Type_value = map[string]int32{
	"UNSPECIFIED":          0,
	"PAYLOAD_ERROR":        1,
	"PRINCIPAL_KEY_ERROR":  2,
	"AUTH_MISSING":         3,
	"AUTH_INVALID":         4,
	"AUTH_EXPIRED":         5,
	"AUTH_REUSED":          6,
	"AUTH_DENIED":          7,
	"RESOURCE_DENIED":      8,
	"RESOURCE_LIMIT":       9,
	"RATE_LIMIT":           10,
	"MODULE_NOT_FOUND":     11,
	"MODULE_HASH_MISMATCH": 12,
	"MODULE_ERROR":         13,
	"FUNCTION_NOT_FOUND":   14,
	"PROGRAM_ERROR":        15,
	"INSTANCE_NOT_FOUND":   16,
	"INSTANCE_ID_INVALID":  17,
	"INSTANCE_ID_EXISTS":   18,
	"INSTANCE_STATUS":      19,
	"INSTANCE_NO_CONNECT":  20,
	"INSTANCE_TRANSIENT":   21,
}

func (x FailRequest_Type) String() string {
	return proto.EnumName(FailRequest_Type_name, int32(x))
}
func (FailRequest_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{3, 0}
}

type FailInternal struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Source               string         `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	Function             string         `protobuf:"bytes,4,opt,name=function,proto3" json:"function,omitempty"`
	Instance             string         `protobuf:"bytes,5,opt,name=instance,proto3" json:"instance,omitempty"`
	Subsystem            string         `protobuf:"bytes,6,opt,name=subsystem,proto3" json:"subsystem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FailInternal) Reset()         { *m = FailInternal{} }
func (m *FailInternal) String() string { return proto.CompactTextString(m) }
func (*FailInternal) ProtoMessage()    {}
func (*FailInternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{0}
}
func (m *FailInternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailInternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailInternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailInternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailInternal.Merge(dst, src)
}
func (m *FailInternal) XXX_Size() int {
	return m.Size()
}
func (m *FailInternal) XXX_DiscardUnknown() {
	xxx_messageInfo_FailInternal.DiscardUnknown(m)
}

var xxx_messageInfo_FailInternal proto.InternalMessageInfo

type FailNetwork struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FailNetwork) Reset()         { *m = FailNetwork{} }
func (m *FailNetwork) String() string { return proto.CompactTextString(m) }
func (*FailNetwork) ProtoMessage()    {}
func (*FailNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{1}
}
func (m *FailNetwork) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailNetwork.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailNetwork.Merge(dst, src)
}
func (m *FailNetwork) XXX_Size() int {
	return m.Size()
}
func (m *FailNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_FailNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_FailNetwork proto.InternalMessageInfo

type FailProtocol struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FailProtocol) Reset()         { *m = FailProtocol{} }
func (m *FailProtocol) String() string { return proto.CompactTextString(m) }
func (*FailProtocol) ProtoMessage()    {}
func (*FailProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{2}
}
func (m *FailProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailProtocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailProtocol.Merge(dst, src)
}
func (m *FailProtocol) XXX_Size() int {
	return m.Size()
}
func (m *FailProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_FailProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_FailProtocol proto.InternalMessageInfo

type FailRequest struct {
	Ctx                  detail.Context   `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Failure              FailRequest_Type `protobuf:"varint,2,opt,name=failure,proto3,enum=server.event.FailRequest_Type" json:"failure,omitempty"`
	Source               string           `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	Module               string           `protobuf:"bytes,4,opt,name=module,proto3" json:"module,omitempty"`
	Function             string           `protobuf:"bytes,5,opt,name=function,proto3" json:"function,omitempty"`
	Instance             string           `protobuf:"bytes,6,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FailRequest) Reset()         { *m = FailRequest{} }
func (m *FailRequest) String() string { return proto.CompactTextString(m) }
func (*FailRequest) ProtoMessage()    {}
func (*FailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{3}
}
func (m *FailRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailRequest.Merge(dst, src)
}
func (m *FailRequest) XXX_Size() int {
	return m.Size()
}
func (m *FailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FailRequest proto.InternalMessageInfo

type IfaceAccess struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *IfaceAccess) Reset()         { *m = IfaceAccess{} }
func (m *IfaceAccess) String() string { return proto.CompactTextString(m) }
func (*IfaceAccess) ProtoMessage()    {}
func (*IfaceAccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{4}
}
func (m *IfaceAccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IfaceAccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IfaceAccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IfaceAccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfaceAccess.Merge(dst, src)
}
func (m *IfaceAccess) XXX_Size() int {
	return m.Size()
}
func (m *IfaceAccess) XXX_DiscardUnknown() {
	xxx_messageInfo_IfaceAccess.DiscardUnknown(m)
}

var xxx_messageInfo_IfaceAccess proto.InternalMessageInfo

type OpUnsupported struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *OpUnsupported) Reset()         { *m = OpUnsupported{} }
func (m *OpUnsupported) String() string { return proto.CompactTextString(m) }
func (*OpUnsupported) ProtoMessage()    {}
func (*OpUnsupported) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{5}
}
func (m *OpUnsupported) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpUnsupported) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpUnsupported.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpUnsupported) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpUnsupported.Merge(dst, src)
}
func (m *OpUnsupported) XXX_Size() int {
	return m.Size()
}
func (m *OpUnsupported) XXX_DiscardUnknown() {
	xxx_messageInfo_OpUnsupported.DiscardUnknown(m)
}

var xxx_messageInfo_OpUnsupported proto.InternalMessageInfo

type ModuleList struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleList) Reset()         { *m = ModuleList{} }
func (m *ModuleList) String() string { return proto.CompactTextString(m) }
func (*ModuleList) ProtoMessage()    {}
func (*ModuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{6}
}
func (m *ModuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleList.Merge(dst, src)
}
func (m *ModuleList) XXX_Size() int {
	return m.Size()
}
func (m *ModuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleList.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleList proto.InternalMessageInfo

type ModuleUploadNew struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleUploadNew) Reset()         { *m = ModuleUploadNew{} }
func (m *ModuleUploadNew) String() string { return proto.CompactTextString(m) }
func (*ModuleUploadNew) ProtoMessage()    {}
func (*ModuleUploadNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{7}
}
func (m *ModuleUploadNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleUploadNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleUploadNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleUploadNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleUploadNew.Merge(dst, src)
}
func (m *ModuleUploadNew) XXX_Size() int {
	return m.Size()
}
func (m *ModuleUploadNew) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleUploadNew.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleUploadNew proto.InternalMessageInfo

type ModuleUploadExist struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Compiled             bool           `protobuf:"varint,3,opt,name=compiled,proto3" json:"compiled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleUploadExist) Reset()         { *m = ModuleUploadExist{} }
func (m *ModuleUploadExist) String() string { return proto.CompactTextString(m) }
func (*ModuleUploadExist) ProtoMessage()    {}
func (*ModuleUploadExist) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{8}
}
func (m *ModuleUploadExist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleUploadExist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleUploadExist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleUploadExist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleUploadExist.Merge(dst, src)
}
func (m *ModuleUploadExist) XXX_Size() int {
	return m.Size()
}
func (m *ModuleUploadExist) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleUploadExist.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleUploadExist proto.InternalMessageInfo

type ModuleSourceNew struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Uri                  string         `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleSourceNew) Reset()         { *m = ModuleSourceNew{} }
func (m *ModuleSourceNew) String() string { return proto.CompactTextString(m) }
func (*ModuleSourceNew) ProtoMessage()    {}
func (*ModuleSourceNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{9}
}
func (m *ModuleSourceNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleSourceNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleSourceNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleSourceNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleSourceNew.Merge(dst, src)
}
func (m *ModuleSourceNew) XXX_Size() int {
	return m.Size()
}
func (m *ModuleSourceNew) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleSourceNew.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleSourceNew proto.InternalMessageInfo

type ModuleSourceExist struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Uri                  string         `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	Compiled             bool           `protobuf:"varint,4,opt,name=compiled,proto3" json:"compiled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleSourceExist) Reset()         { *m = ModuleSourceExist{} }
func (m *ModuleSourceExist) String() string { return proto.CompactTextString(m) }
func (*ModuleSourceExist) ProtoMessage()    {}
func (*ModuleSourceExist) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{10}
}
func (m *ModuleSourceExist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleSourceExist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleSourceExist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleSourceExist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleSourceExist.Merge(dst, src)
}
func (m *ModuleSourceExist) XXX_Size() int {
	return m.Size()
}
func (m *ModuleSourceExist) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleSourceExist.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleSourceExist proto.InternalMessageInfo

type ModuleDownload struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	ModuleLength         uint64         `protobuf:"varint,3,opt,name=module_length,json=moduleLength,proto3" json:"module_length,omitempty"`
	LengthRead           uint64         `protobuf:"varint,4,opt,name=length_read,json=lengthRead,proto3" json:"length_read,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleDownload) Reset()         { *m = ModuleDownload{} }
func (m *ModuleDownload) String() string { return proto.CompactTextString(m) }
func (*ModuleDownload) ProtoMessage()    {}
func (*ModuleDownload) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{11}
}
func (m *ModuleDownload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleDownload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleDownload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleDownload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleDownload.Merge(dst, src)
}
func (m *ModuleDownload) XXX_Size() int {
	return m.Size()
}
func (m *ModuleDownload) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleDownload.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleDownload proto.InternalMessageInfo

type ModuleUnref struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleUnref) Reset()         { *m = ModuleUnref{} }
func (m *ModuleUnref) String() string { return proto.CompactTextString(m) }
func (*ModuleUnref) ProtoMessage()    {}
func (*ModuleUnref) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{12}
}
func (m *ModuleUnref) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleUnref) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleUnref.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleUnref) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleUnref.Merge(dst, src)
}
func (m *ModuleUnref) XXX_Size() int {
	return m.Size()
}
func (m *ModuleUnref) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleUnref.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleUnref proto.InternalMessageInfo

type InstanceList struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceList) Reset()         { *m = InstanceList{} }
func (m *InstanceList) String() string { return proto.CompactTextString(m) }
func (*InstanceList) ProtoMessage()    {}
func (*InstanceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{13}
}
func (m *InstanceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceList.Merge(dst, src)
}
func (m *InstanceList) XXX_Size() int {
	return m.Size()
}
func (m *InstanceList) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceList.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceList proto.InternalMessageInfo

type InstanceCreateStream struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceCreateStream) Reset()         { *m = InstanceCreateStream{} }
func (m *InstanceCreateStream) String() string { return proto.CompactTextString(m) }
func (*InstanceCreateStream) ProtoMessage()    {}
func (*InstanceCreateStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{14}
}
func (m *InstanceCreateStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceCreateStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceCreateStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceCreateStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceCreateStream.Merge(dst, src)
}
func (m *InstanceCreateStream) XXX_Size() int {
	return m.Size()
}
func (m *InstanceCreateStream) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceCreateStream.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceCreateStream proto.InternalMessageInfo

type InstanceCreateLocal struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceCreateLocal) Reset()         { *m = InstanceCreateLocal{} }
func (m *InstanceCreateLocal) String() string { return proto.CompactTextString(m) }
func (*InstanceCreateLocal) ProtoMessage()    {}
func (*InstanceCreateLocal) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{15}
}
func (m *InstanceCreateLocal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceCreateLocal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceCreateLocal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceCreateLocal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceCreateLocal.Merge(dst, src)
}
func (m *InstanceCreateLocal) XXX_Size() int {
	return m.Size()
}
func (m *InstanceCreateLocal) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceCreateLocal.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceCreateLocal proto.InternalMessageInfo

type InstanceDelete struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceDelete) Reset()         { *m = InstanceDelete{} }
func (m *InstanceDelete) String() string { return proto.CompactTextString(m) }
func (*InstanceDelete) ProtoMessage()    {}
func (*InstanceDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{16}
}
func (m *InstanceDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceDelete.Merge(dst, src)
}
func (m *InstanceDelete) XXX_Size() int {
	return m.Size()
}
func (m *InstanceDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceDelete.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceDelete proto.InternalMessageInfo

type InstanceConnect struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceConnect) Reset()         { *m = InstanceConnect{} }
func (m *InstanceConnect) String() string { return proto.CompactTextString(m) }
func (*InstanceConnect) ProtoMessage()    {}
func (*InstanceConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{17}
}
func (m *InstanceConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceConnect.Merge(dst, src)
}
func (m *InstanceConnect) XXX_Size() int {
	return m.Size()
}
func (m *InstanceConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceConnect.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceConnect proto.InternalMessageInfo

type InstanceDisconnect struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceDisconnect) Reset()         { *m = InstanceDisconnect{} }
func (m *InstanceDisconnect) String() string { return proto.CompactTextString(m) }
func (*InstanceDisconnect) ProtoMessage()    {}
func (*InstanceDisconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{18}
}
func (m *InstanceDisconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceDisconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceDisconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceDisconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceDisconnect.Merge(dst, src)
}
func (m *InstanceDisconnect) XXX_Size() int {
	return m.Size()
}
func (m *InstanceDisconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceDisconnect.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceDisconnect proto.InternalMessageInfo

type InstanceStatus struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceStatus) Reset()         { *m = InstanceStatus{} }
func (m *InstanceStatus) String() string { return proto.CompactTextString(m) }
func (*InstanceStatus) ProtoMessage()    {}
func (*InstanceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{19}
}
func (m *InstanceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceStatus.Merge(dst, src)
}
func (m *InstanceStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstanceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceStatus proto.InternalMessageInfo

type InstanceWait struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceWait) Reset()         { *m = InstanceWait{} }
func (m *InstanceWait) String() string { return proto.CompactTextString(m) }
func (*InstanceWait) ProtoMessage()    {}
func (*InstanceWait) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{20}
}
func (m *InstanceWait) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceWait) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceWait.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceWait) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceWait.Merge(dst, src)
}
func (m *InstanceWait) XXX_Size() int {
	return m.Size()
}
func (m *InstanceWait) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceWait.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceWait proto.InternalMessageInfo

type InstanceSuspend struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceSuspend) Reset()         { *m = InstanceSuspend{} }
func (m *InstanceSuspend) String() string { return proto.CompactTextString(m) }
func (*InstanceSuspend) ProtoMessage()    {}
func (*InstanceSuspend) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{21}
}
func (m *InstanceSuspend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceSuspend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceSuspend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceSuspend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceSuspend.Merge(dst, src)
}
func (m *InstanceSuspend) XXX_Size() int {
	return m.Size()
}
func (m *InstanceSuspend) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceSuspend.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceSuspend proto.InternalMessageInfo

type InstanceResume struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Function             string         `protobuf:"bytes,3,opt,name=function,proto3" json:"function,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceResume) Reset()         { *m = InstanceResume{} }
func (m *InstanceResume) String() string { return proto.CompactTextString(m) }
func (*InstanceResume) ProtoMessage()    {}
func (*InstanceResume) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{22}
}
func (m *InstanceResume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceResume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceResume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceResume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceResume.Merge(dst, src)
}
func (m *InstanceResume) XXX_Size() int {
	return m.Size()
}
func (m *InstanceResume) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceResume.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceResume proto.InternalMessageInfo

type InstanceSnapshot struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceSnapshot) Reset()         { *m = InstanceSnapshot{} }
func (m *InstanceSnapshot) String() string { return proto.CompactTextString(m) }
func (*InstanceSnapshot) ProtoMessage()    {}
func (*InstanceSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_ea33d6017407c9a1, []int{23}
}
func (m *InstanceSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceSnapshot.Merge(dst, src)
}
func (m *InstanceSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *InstanceSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceSnapshot proto.InternalMessageInfo

func init() {
	proto.RegisterType((*FailInternal)(nil), "server.event.FailInternal")
	proto.RegisterType((*FailNetwork)(nil), "server.event.FailNetwork")
	proto.RegisterType((*FailProtocol)(nil), "server.event.FailProtocol")
	proto.RegisterType((*FailRequest)(nil), "server.event.FailRequest")
	proto.RegisterType((*IfaceAccess)(nil), "server.event.IfaceAccess")
	proto.RegisterType((*OpUnsupported)(nil), "server.event.OpUnsupported")
	proto.RegisterType((*ModuleList)(nil), "server.event.ModuleList")
	proto.RegisterType((*ModuleUploadNew)(nil), "server.event.ModuleUploadNew")
	proto.RegisterType((*ModuleUploadExist)(nil), "server.event.ModuleUploadExist")
	proto.RegisterType((*ModuleSourceNew)(nil), "server.event.ModuleSourceNew")
	proto.RegisterType((*ModuleSourceExist)(nil), "server.event.ModuleSourceExist")
	proto.RegisterType((*ModuleDownload)(nil), "server.event.ModuleDownload")
	proto.RegisterType((*ModuleUnref)(nil), "server.event.ModuleUnref")
	proto.RegisterType((*InstanceList)(nil), "server.event.InstanceList")
	proto.RegisterType((*InstanceCreateStream)(nil), "server.event.InstanceCreateStream")
	proto.RegisterType((*InstanceCreateLocal)(nil), "server.event.InstanceCreateLocal")
	proto.RegisterType((*InstanceDelete)(nil), "server.event.InstanceDelete")
	proto.RegisterType((*InstanceConnect)(nil), "server.event.InstanceConnect")
	proto.RegisterType((*InstanceDisconnect)(nil), "server.event.InstanceDisconnect")
	proto.RegisterType((*InstanceStatus)(nil), "server.event.InstanceStatus")
	proto.RegisterType((*InstanceWait)(nil), "server.event.InstanceWait")
	proto.RegisterType((*InstanceSuspend)(nil), "server.event.InstanceSuspend")
	proto.RegisterType((*InstanceResume)(nil), "server.event.InstanceResume")
	proto.RegisterType((*InstanceSnapshot)(nil), "server.event.InstanceSnapshot")
	proto.RegisterEnum("server.event.Type", Type_name, Type_value)
	proto.RegisterEnum("server.event.FailRequest_Type", FailRequest_Type_name, FailRequest_Type_value)
}
func (m *FailInternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailInternal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n1, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Function) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Function)))
		i += copy(dAtA[i:], m.Function)
	}
	if len(m.Instance) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Subsystem) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Subsystem)))
		i += copy(dAtA[i:], m.Subsystem)
	}
	return i, nil
}

func (m *FailNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n2, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *FailProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailProtocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n3, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *FailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n4, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.Failure != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvent(dAtA, i, uint64(m.Failure))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Function) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Function)))
		i += copy(dAtA[i:], m.Function)
	}
	if len(m.Instance) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *IfaceAccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IfaceAccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n5, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *OpUnsupported) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpUnsupported) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n6, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *ModuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n7, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *ModuleUploadNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleUploadNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n8, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *ModuleUploadExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleUploadExist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n9, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if m.Compiled {
		dAtA[i] = 0x18
		i++
		if m.Compiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ModuleSourceNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSourceNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n10, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	return i, nil
}

func (m *ModuleSourceExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSourceExist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n11, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Compiled {
		dAtA[i] = 0x20
		i++
		if m.Compiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ModuleDownload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleDownload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n12, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if m.ModuleLength != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEvent(dAtA, i, uint64(m.ModuleLength))
	}
	if m.LengthRead != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEvent(dAtA, i, uint64(m.LengthRead))
	}
	return i, nil
}

func (m *ModuleUnref) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleUnref) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n13, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *InstanceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n14, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *InstanceCreateStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCreateStream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n15, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *InstanceCreateLocal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCreateLocal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n16, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *InstanceDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n17, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n18, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceDisconnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n19, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n20, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceWait) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceWait) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n21, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceSuspend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceSuspend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n22, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceResume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceResume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n23, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Function) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Function)))
		i += copy(dAtA[i:], m.Function)
	}
	return i, nil
}

func (m *InstanceSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceSnapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n24, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FailInternal) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Function)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Subsystem)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *FailNetwork) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *FailProtocol) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *FailRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	if m.Failure != 0 {
		n += 1 + sovEvent(uint64(m.Failure))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Function)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *IfaceAccess) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *OpUnsupported) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *ModuleList) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *ModuleUploadNew) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ModuleUploadExist) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Compiled {
		n += 2
	}
	return n
}

func (m *ModuleSourceNew) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ModuleSourceExist) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Compiled {
		n += 2
	}
	return n
}

func (m *ModuleDownload) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.ModuleLength != 0 {
		n += 1 + sovEvent(uint64(m.ModuleLength))
	}
	if m.LengthRead != 0 {
		n += 1 + sovEvent(uint64(m.LengthRead))
	}
	return n
}

func (m *ModuleUnref) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceList) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *InstanceCreateStream) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceCreateLocal) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceDelete) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceConnect) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceDisconnect) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceStatus) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceWait) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceSuspend) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceResume) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Function)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceSnapshot) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func sovEvent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FailInternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailInternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailInternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Function = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subsystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			m.Failure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Failure |= (FailRequest_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Function = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IfaceAccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IfaceAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IfaceAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpUnsupported) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpUnsupported: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpUnsupported: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleUploadNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleUploadNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleUploadNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleUploadExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleUploadExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleUploadExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compiled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSourceNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleSourceNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleSourceNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSourceExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleSourceExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleSourceExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compiled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleDownload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleDownload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleDownload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleLength", wireType)
			}
			m.ModuleLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModuleLength |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LengthRead", wireType)
			}
			m.LengthRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LengthRead |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleUnref) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleUnref: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleUnref: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCreateStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCreateStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCreateStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCreateLocal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCreateLocal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCreateLocal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceWait) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceWait: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceWait: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceSuspend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceSuspend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceSuspend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceResume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceResume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceResume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Function = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEvent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEvent(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEvent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("server/event/event.proto", fileDescriptor_event_ea33d6017407c9a1) }

var fileDescriptor_event_ea33d6017407c9a1 = []byte{
	// 1168 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0x8e, 0x63, 0x27, 0x4d, 0xd6, 0x8e, 0xb3, 0xd9, 0xfc, 0x60, 0x32, 0x4c, 0xda, 0x11, 0x5c,
	0x74, 0xb8, 0x70, 0x66, 0xca, 0x0d, 0xc3, 0x40, 0x19, 0x55, 0x5a, 0x37, 0x3b, 0x95, 0x57, 0x66,
	0x57, 0x22, 0x6d, 0x07, 0xc6, 0xa8, 0xf2, 0xa6, 0xf5, 0xd4, 0x91, 0x8c, 0xb4, 0x4a, 0x52, 0xde,
	0x80, 0x3b, 0x9e, 0x80, 0x87, 0xe0, 0x19, 0xb8, 0xe8, 0x65, 0x9f, 0x80, 0x81, 0xf2, 0x06, 0x3c,
	0x01, 0xb3, 0x92, 0xac, 0x48, 0x81, 0x30, 0xe3, 0x8c, 0xcb, 0x4d, 0xa2, 0xfd, 0xce, 0xd9, 0xf3,
	0xf3, 0x79, 0xcf, 0xea, 0x13, 0xe8, 0xc4, 0x22, 0x3a, 0x13, 0xd1, 0xa1, 0x38, 0x13, 0x81, 0xcc,
	0xfe, 0x76, 0xa7, 0x51, 0x28, 0x43, 0xd4, 0xca, 0x2c, 0xdd, 0x14, 0xdb, 0xdf, 0xcf, 0xfd, 0x46,
	0x42, 0x7a, 0xe3, 0x49, 0xfe, 0x2f, 0xf3, 0xd4, 0x7e, 0xad, 0x81, 0x56, 0xcf, 0x1b, 0x4f, 0x48,
	0x20, 0x45, 0x14, 0x78, 0x13, 0xd4, 0x05, 0x75, 0x5f, 0x5e, 0x74, 0x6a, 0x77, 0x6a, 0x77, 0x9b,
	0xf7, 0xf6, 0xba, 0x79, 0xa0, 0x7c, 0x8f, 0x11, 0x06, 0x52, 0x5c, 0xc8, 0x07, 0x8d, 0xd7, 0xbf,
	0xdd, 0x5e, 0x62, 0xca, 0x11, 0xed, 0x81, 0xd5, 0x38, 0x4c, 0x22, 0x5f, 0x74, 0x96, 0xef, 0xd4,
	0xee, 0xae, 0xb3, 0x7c, 0xa5, 0xf0, 0xd3, 0x70, 0x94, 0x4c, 0x44, 0xa7, 0x9e, 0xe1, 0xd9, 0x0a,
	0xed, 0x83, 0xb5, 0x93, 0x24, 0xf0, 0xe5, 0x38, 0x0c, 0x3a, 0x8d, 0xd4, 0x52, 0xac, 0x95, 0x6d,
	0x1c, 0xc4, 0xd2, 0x0b, 0x7c, 0xd1, 0x59, 0xc9, 0x6c, 0xb3, 0x35, 0xfa, 0x00, 0xac, 0xc7, 0xc9,
	0xb3, 0xf8, 0x55, 0x2c, 0xc5, 0x69, 0x67, 0x35, 0x35, 0x5e, 0x02, 0xda, 0x17, 0xa0, 0xa9, 0xba,
	0xa0, 0x42, 0x9e, 0x87, 0xd1, 0xcb, 0x79, 0x9b, 0xd0, 0xee, 0x67, 0x24, 0x0c, 0x14, 0x25, 0x7e,
	0x38, 0x37, 0x09, 0xda, 0x2f, 0x2b, 0x59, 0x7e, 0x26, 0xbe, 0x4f, 0x44, 0x2c, 0xe7, 0x26, 0xf1,
	0x53, 0x70, 0xeb, 0xc4, 0x1b, 0x4f, 0x92, 0x28, 0x63, 0xb1, 0x7d, 0xef, 0xa0, 0x5b, 0xfe, 0x05,
	0xbb, 0xa5, 0xd8, 0x5d, 0xe7, 0xd5, 0x54, 0xb0, 0x99, 0x7b, 0x89, 0xfe, 0xfa, 0x35, 0xf4, 0x37,
	0xae, 0xa5, 0x7f, 0xe5, 0x3f, 0xe8, 0x5f, 0xad, 0xd2, 0xaf, 0xbd, 0xa9, 0x83, 0x86, 0xca, 0x8c,
	0x36, 0x41, 0xd3, 0xa5, 0x7c, 0x80, 0x0d, 0xd2, 0x23, 0xd8, 0x84, 0x4b, 0x68, 0x0b, 0x6c, 0x0c,
	0xf4, 0x27, 0x96, 0xad, 0x9b, 0x43, 0xcc, 0x98, 0xcd, 0x60, 0x0d, 0xbd, 0x07, 0xb6, 0x07, 0x8c,
	0x50, 0x83, 0x0c, 0x74, 0x6b, 0xf8, 0x08, 0x3f, 0xc9, 0x0d, 0xcb, 0x08, 0x82, 0x96, 0xee, 0x3a,
	0x47, 0xc3, 0x3e, 0xe1, 0x9c, 0xd0, 0x87, 0xb0, 0x5e, 0x20, 0x84, 0x7e, 0xad, 0x5b, 0xc4, 0x84,
	0x8d, 0x02, 0xc1, 0x8f, 0x07, 0x84, 0x61, 0x13, 0xae, 0xa8, 0x94, 0x29, 0xc2, 0xb0, 0xcb, 0xb1,
	0x09, 0x57, 0x0b, 0xc0, 0xc4, 0x54, 0xd5, 0x70, 0x0b, 0x6d, 0x83, 0x4d, 0x86, 0xb9, 0xed, 0x32,
	0x03, 0xcf, 0xc0, 0x35, 0x84, 0x40, 0xbb, 0x00, 0x2d, 0xd2, 0x27, 0x0e, 0x5c, 0x47, 0x6d, 0x00,
	0x98, 0xee, 0xcc, 0xd6, 0x00, 0xed, 0x00, 0xd8, 0xb7, 0x4d, 0xd7, 0xc2, 0x43, 0x6a, 0x3b, 0xc3,
	0x9e, 0xed, 0x52, 0x13, 0x36, 0x51, 0x07, 0xec, 0xe4, 0xe8, 0x91, 0xce, 0xd3, 0x6a, 0xfb, 0xba,
	0x63, 0x1c, 0xc1, 0x96, 0x2a, 0x2e, 0xb7, 0x64, 0x2d, 0x6d, 0xa0, 0x3d, 0x80, 0x7a, 0x2e, 0x35,
	0x1c, 0x62, 0xd3, 0x52, 0x8c, 0x76, 0x4a, 0x0b, 0xb3, 0x1f, 0x32, 0xbd, 0x9f, 0xbb, 0x6e, 0x2a,
	0x57, 0x42, 0xb9, 0xa3, 0x53, 0xa3, 0x9c, 0x0e, 0x2a, 0xba, 0x0a, 0x9c, 0x98, 0x05, 0x15, 0x5b,
	0x95, 0x0d, 0xc4, 0x1c, 0xe2, 0xc7, 0x84, 0x3b, 0x1c, 0x22, 0xd5, 0x6e, 0x81, 0x73, 0x47, 0x77,
	0x5c, 0x0e, 0xb7, 0x2b, 0x51, 0xa8, 0x3d, 0x34, 0x6c, 0x4a, 0xb1, 0xe1, 0xc0, 0x9d, 0x4a, 0x14,
	0x87, 0xe9, 0x94, 0x13, 0x4c, 0x1d, 0xb8, 0xab, 0x66, 0x86, 0x9c, 0x78, 0xbe, 0xd0, 0x7d, 0x5f,
	0xc4, 0xf1, 0xdc, 0x67, 0xfe, 0x4b, 0xb0, 0x61, 0x4f, 0xdd, 0x20, 0x4e, 0xa6, 0xd3, 0x30, 0x92,
	0x62, 0x34, 0x77, 0x80, 0xcf, 0x01, 0xe8, 0xa7, 0x87, 0xd2, 0x1a, 0xcf, 0x3f, 0x32, 0xda, 0x13,
	0xb0, 0x99, 0xed, 0x76, 0xa7, 0x93, 0xd0, 0x1b, 0x51, 0x71, 0x7e, 0x93, 0xab, 0x2b, 0x9f, 0x91,
	0xe5, 0xf2, 0x8c, 0x68, 0xe7, 0x60, 0xab, 0x1c, 0x1a, 0x5f, 0xdc, 0xa0, 0xbe, 0xeb, 0x82, 0xab,
	0x21, 0xf3, 0xc3, 0xd3, 0xe9, 0x78, 0x22, 0x46, 0xe9, 0xc8, 0xae, 0xb1, 0x62, 0xad, 0xbd, 0x9c,
	0xf5, 0xc4, 0xd3, 0x21, 0x5e, 0x60, 0x4f, 0x08, 0x82, 0x7a, 0x12, 0x8d, 0xf3, 0x4b, 0x42, 0x3d,
	0x6a, 0x3f, 0xd6, 0x66, 0x6d, 0x66, 0xd9, 0x16, 0xdb, 0xe6, 0x3f, 0xf2, 0x55, 0x1a, 0x6f, 0x5c,
	0x69, 0xfc, 0xe7, 0x1a, 0x68, 0x67, 0xb5, 0x98, 0xe1, 0x79, 0xa0, 0x48, 0x5f, 0x58, 0x21, 0x1f,
	0x82, 0x8d, 0xec, 0x69, 0x38, 0x11, 0xc1, 0x73, 0xf9, 0x22, 0x2d, 0xa9, 0xc1, 0x5a, 0x19, 0x68,
	0xa5, 0x18, 0xba, 0x0d, 0x9a, 0x99, 0x75, 0x18, 0x09, 0x2f, 0x2b, 0xaf, 0xc1, 0x40, 0x06, 0x31,
	0xe1, 0x8d, 0x34, 0x17, 0x34, 0xf3, 0x23, 0x11, 0x44, 0xe2, 0x64, 0x61, 0x27, 0xed, 0x3e, 0x68,
	0x91, 0xfc, 0x86, 0xbd, 0xd1, 0x10, 0xfc, 0x00, 0x76, 0x66, 0xfb, 0x8d, 0x48, 0x78, 0x52, 0x70,
	0x19, 0x09, 0xef, 0x74, 0xee, 0xfa, 0xca, 0x37, 0xff, 0xf2, 0x95, 0x17, 0xef, 0x35, 0x2f, 0x72,
	0xed, 0x15, 0xd8, 0xae, 0xe6, 0xb6, 0x42, 0xff, 0x06, 0xfa, 0xe1, 0x26, 0xa9, 0xbf, 0x01, 0xed,
	0x59, 0x6a, 0x53, 0x4c, 0x84, 0x14, 0x8b, 0xcc, 0xaa, 0x7d, 0x0b, 0x36, 0x8b, 0xc6, 0xc2, 0x20,
	0x10, 0xbe, 0x5c, 0x68, 0xf8, 0xef, 0x00, 0x2a, 0x8a, 0x1f, 0xc7, 0xfe, 0x3b, 0xc8, 0x50, 0xa2,
	0x87, 0x4b, 0x4f, 0x26, 0xf1, 0x42, 0xa3, 0x3f, 0xbd, 0x3c, 0xb3, 0xc7, 0xde, 0x58, 0xbe, 0x2b,
	0xea, 0x79, 0x12, 0x4f, 0x45, 0x30, 0x5a, 0x68, 0xf8, 0x8b, 0x4b, 0x62, 0x98, 0x88, 0x93, 0xd3,
	0x85, 0x9e, 0x9b, 0x8a, 0xb4, 0xaa, 0x57, 0xa5, 0x95, 0x76, 0x06, 0x60, 0xd1, 0x58, 0xe0, 0x4d,
	0xe3, 0x17, 0xa1, 0xfc, 0x3f, 0x26, 0xe5, 0xe3, 0xbf, 0x66, 0xb2, 0x6d, 0x0b, 0x6c, 0xf4, 0x74,
	0x62, 0x0d, 0x09, 0x75, 0x30, 0xa3, 0xba, 0x05, 0x97, 0x94, 0x96, 0x49, 0x21, 0x8a, 0x9d, 0x63,
	0x9b, 0x3d, 0x82, 0xb5, 0xc2, 0x69, 0xc0, 0x6c, 0xc7, 0x36, 0x6c, 0x2b, 0x53, 0x6c, 0x29, 0xc4,
	0xf0, 0x57, 0x2e, 0xe6, 0x4e, 0xa6, 0xd8, 0x48, 0x4f, 0x37, 0xf0, 0x50, 0x37, 0x0c, 0xcc, 0x39,
	0x6c, 0x28, 0x39, 0x96, 0x8b, 0x22, 0x8b, 0x70, 0x07, 0xae, 0xa0, 0x5d, 0xb0, 0x95, 0x03, 0xee,
	0x20, 0x15, 0x86, 0x14, 0x1f, 0xc3, 0x55, 0xa5, 0x50, 0xaa, 0x70, 0x2a, 0x68, 0xe0, 0xad, 0x92,
	0x7f, 0x2e, 0xd7, 0x94, 0xff, 0x5a, 0xc9, 0x3f, 0x87, 0x33, 0xff, 0x75, 0xa5, 0x7f, 0x72, 0x83,
	0x69, 0x1f, 0x53, 0x15, 0x0a, 0x82, 0x92, 0x34, 0x73, 0x29, 0xc3, 0x3d, 0xd8, 0x54, 0xed, 0x14,
	0xc2, 0x27, 0xad, 0xac, 0x85, 0xf6, 0xc1, 0x5e, 0x01, 0x19, 0x0c, 0x2b, 0x29, 0xc8, 0x1d, 0x86,
	0xf5, 0x3e, 0xdc, 0x40, 0xef, 0x83, 0xdd, 0xab, 0x36, 0xcb, 0x36, 0x74, 0x0b, 0xb6, 0x2b, 0x82,
	0xcb, 0xc4, 0x16, 0x76, 0x30, 0xdc, 0x54, 0xda, 0xf1, 0xd2, 0x3f, 0x57, 0x5b, 0x55, 0x31, 0x67,
	0x12, 0x3e, 0x33, 0x6c, 0xfd, 0x9b, 0x68, 0x43, 0x95, 0x12, 0x8f, 0x75, 0xe2, 0xc0, 0xed, 0x4a,
	0x58, 0xee, 0xf2, 0x01, 0xa6, 0x26, 0xdc, 0xa9, 0xec, 0x66, 0x98, 0xbb, 0x7d, 0x0c, 0x77, 0x15,
	0x6f, 0x97, 0xae, 0x54, 0x1f, 0xf0, 0x23, 0xdb, 0x81, 0x7b, 0x0f, 0x3e, 0x7b, 0xfd, 0xc7, 0xc1,
	0xd2, 0xeb, 0xb7, 0x07, 0xb5, 0x37, 0x6f, 0x0f, 0x6a, 0xbf, 0xbf, 0x3d, 0xa8, 0xfd, 0xf4, 0xe7,
	0xc1, 0xd2, 0xd3, 0x8f, 0x9e, 0x8f, 0xe5, 0x8b, 0xe4, 0x59, 0xd7, 0x0f, 0x4f, 0x0f, 0x65, 0xec,
	0x9d, 0x85, 0x13, 0xef, 0xf0, 0xb9, 0x27, 0xc5, 0x61, 0xf9, 0x2b, 0xf2, 0xd9, 0x6a, 0xfa, 0x59,
	0xf8, 0xc9, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe7, 0x58, 0xe7, 0x73, 0x5c, 0x0e, 0x00, 0x00,
}
