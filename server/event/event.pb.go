// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/event/event.proto

package event // import "github.com/tsavola/gate/server/event"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import detail "github.com/tsavola/gate/server/detail"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Event_Type int32

const (
	Event_FailInternal         Event_Type = 0
	Event_FailNetwork          Event_Type = 1
	Event_FailProtocol         Event_Type = 2
	Event_FailRequest          Event_Type = 3
	Event_IfaceAccess          Event_Type = 4
	Event_ModuleList           Event_Type = 5
	Event_ModuleUploadNew      Event_Type = 6
	Event_ModuleUploadExist    Event_Type = 7
	Event_ModuleSourceNew      Event_Type = 8
	Event_ModuleSourceExist    Event_Type = 9
	Event_ModuleDownload       Event_Type = 10
	Event_ModuleUnref          Event_Type = 11
	Event_InstanceList         Event_Type = 12
	Event_InstanceCreateStream Event_Type = 13
	Event_InstanceCreateLocal  Event_Type = 14
	Event_InstanceDelete       Event_Type = 15
	Event_InstanceConnect      Event_Type = 16
	Event_InstanceDisconnect   Event_Type = 17
	Event_InstanceStatus       Event_Type = 18
)

var Event_Type_name = map[int32]string{
	0:  "FailInternal",
	1:  "FailNetwork",
	2:  "FailProtocol",
	3:  "FailRequest",
	4:  "IfaceAccess",
	5:  "ModuleList",
	6:  "ModuleUploadNew",
	7:  "ModuleUploadExist",
	8:  "ModuleSourceNew",
	9:  "ModuleSourceExist",
	10: "ModuleDownload",
	11: "ModuleUnref",
	12: "InstanceList",
	13: "InstanceCreateStream",
	14: "InstanceCreateLocal",
	15: "InstanceDelete",
	16: "InstanceConnect",
	17: "InstanceDisconnect",
	18: "InstanceStatus",
}
var Event_Type_value = map[string]int32{
	"FailInternal":         0,
	"FailNetwork":          1,
	"FailProtocol":         2,
	"FailRequest":          3,
	"IfaceAccess":          4,
	"ModuleList":           5,
	"ModuleUploadNew":      6,
	"ModuleUploadExist":    7,
	"ModuleSourceNew":      8,
	"ModuleSourceExist":    9,
	"ModuleDownload":       10,
	"ModuleUnref":          11,
	"InstanceList":         12,
	"InstanceCreateStream": 13,
	"InstanceCreateLocal":  14,
	"InstanceDelete":       15,
	"InstanceConnect":      16,
	"InstanceDisconnect":   17,
	"InstanceStatus":       18,
}

func (x Event_Type) String() string {
	return proto.EnumName(Event_Type_name, int32(x))
}
func (Event_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{0, 0}
}

type FailRequest_Type int32

const (
	FailRequest_Unspecified        FailRequest_Type = 0
	FailRequest_PayloadError       FailRequest_Type = 1
	FailRequest_PrincipalKeyError  FailRequest_Type = 2
	FailRequest_AuthMissing        FailRequest_Type = 3
	FailRequest_AuthInvalid        FailRequest_Type = 4
	FailRequest_AuthExpired        FailRequest_Type = 5
	FailRequest_AuthReused         FailRequest_Type = 6
	FailRequest_AuthDenied         FailRequest_Type = 7
	FailRequest_ResourceDenied     FailRequest_Type = 8
	FailRequest_ResourceLimit      FailRequest_Type = 9
	FailRequest_RateLimit          FailRequest_Type = 10
	FailRequest_ModuleNotFound     FailRequest_Type = 11
	FailRequest_ModuleHashMismatch FailRequest_Type = 12
	FailRequest_ModuleError        FailRequest_Type = 13
	FailRequest_FunctionNotFound   FailRequest_Type = 14
	FailRequest_ProgramError       FailRequest_Type = 15
	FailRequest_InstanceNotFound   FailRequest_Type = 16
	FailRequest_InstanceIdInvalid  FailRequest_Type = 17
	FailRequest_InstanceIdExists   FailRequest_Type = 18
	FailRequest_InstanceNoConnect  FailRequest_Type = 19
)

var FailRequest_Type_name = map[int32]string{
	0:  "Unspecified",
	1:  "PayloadError",
	2:  "PrincipalKeyError",
	3:  "AuthMissing",
	4:  "AuthInvalid",
	5:  "AuthExpired",
	6:  "AuthReused",
	7:  "AuthDenied",
	8:  "ResourceDenied",
	9:  "ResourceLimit",
	10: "RateLimit",
	11: "ModuleNotFound",
	12: "ModuleHashMismatch",
	13: "ModuleError",
	14: "FunctionNotFound",
	15: "ProgramError",
	16: "InstanceNotFound",
	17: "InstanceIdInvalid",
	18: "InstanceIdExists",
	19: "InstanceNoConnect",
}
var FailRequest_Type_value = map[string]int32{
	"Unspecified":        0,
	"PayloadError":       1,
	"PrincipalKeyError":  2,
	"AuthMissing":        3,
	"AuthInvalid":        4,
	"AuthExpired":        5,
	"AuthReused":         6,
	"AuthDenied":         7,
	"ResourceDenied":     8,
	"ResourceLimit":      9,
	"RateLimit":          10,
	"ModuleNotFound":     11,
	"ModuleHashMismatch": 12,
	"ModuleError":        13,
	"FunctionNotFound":   14,
	"ProgramError":       15,
	"InstanceNotFound":   16,
	"InstanceIdInvalid":  17,
	"InstanceIdExists":   18,
	"InstanceNoConnect":  19,
}

func (x FailRequest_Type) String() string {
	return proto.EnumName(FailRequest_Type_name, int32(x))
}
func (FailRequest_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{4, 0}
}

type Event struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{0}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(dst, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

type FailInternal struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Source               string         `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	Function             string         `protobuf:"bytes,4,opt,name=function,proto3" json:"function,omitempty"`
	Instance             string         `protobuf:"bytes,5,opt,name=instance,proto3" json:"instance,omitempty"`
	Subsystem            string         `protobuf:"bytes,6,opt,name=subsystem,proto3" json:"subsystem,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FailInternal) Reset()         { *m = FailInternal{} }
func (m *FailInternal) String() string { return proto.CompactTextString(m) }
func (*FailInternal) ProtoMessage()    {}
func (*FailInternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{1}
}
func (m *FailInternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailInternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailInternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailInternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailInternal.Merge(dst, src)
}
func (m *FailInternal) XXX_Size() int {
	return m.Size()
}
func (m *FailInternal) XXX_DiscardUnknown() {
	xxx_messageInfo_FailInternal.DiscardUnknown(m)
}

var xxx_messageInfo_FailInternal proto.InternalMessageInfo

type FailNetwork struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FailNetwork) Reset()         { *m = FailNetwork{} }
func (m *FailNetwork) String() string { return proto.CompactTextString(m) }
func (*FailNetwork) ProtoMessage()    {}
func (*FailNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{2}
}
func (m *FailNetwork) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailNetwork.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailNetwork.Merge(dst, src)
}
func (m *FailNetwork) XXX_Size() int {
	return m.Size()
}
func (m *FailNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_FailNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_FailNetwork proto.InternalMessageInfo

type FailProtocol struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FailProtocol) Reset()         { *m = FailProtocol{} }
func (m *FailProtocol) String() string { return proto.CompactTextString(m) }
func (*FailProtocol) ProtoMessage()    {}
func (*FailProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{3}
}
func (m *FailProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailProtocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailProtocol.Merge(dst, src)
}
func (m *FailProtocol) XXX_Size() int {
	return m.Size()
}
func (m *FailProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_FailProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_FailProtocol proto.InternalMessageInfo

type FailRequest struct {
	Ctx                  detail.Context   `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Failure              FailRequest_Type `protobuf:"varint,2,opt,name=failure,proto3,enum=event.FailRequest_Type" json:"failure,omitempty"`
	Source               string           `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	Module               string           `protobuf:"bytes,4,opt,name=module,proto3" json:"module,omitempty"`
	Function             string           `protobuf:"bytes,5,opt,name=function,proto3" json:"function,omitempty"`
	Instance             string           `protobuf:"bytes,6,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FailRequest) Reset()         { *m = FailRequest{} }
func (m *FailRequest) String() string { return proto.CompactTextString(m) }
func (*FailRequest) ProtoMessage()    {}
func (*FailRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{4}
}
func (m *FailRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FailRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailRequest.Merge(dst, src)
}
func (m *FailRequest) XXX_Size() int {
	return m.Size()
}
func (m *FailRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FailRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FailRequest proto.InternalMessageInfo

type IfaceAccess struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *IfaceAccess) Reset()         { *m = IfaceAccess{} }
func (m *IfaceAccess) String() string { return proto.CompactTextString(m) }
func (*IfaceAccess) ProtoMessage()    {}
func (*IfaceAccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{5}
}
func (m *IfaceAccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IfaceAccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IfaceAccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IfaceAccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IfaceAccess.Merge(dst, src)
}
func (m *IfaceAccess) XXX_Size() int {
	return m.Size()
}
func (m *IfaceAccess) XXX_DiscardUnknown() {
	xxx_messageInfo_IfaceAccess.DiscardUnknown(m)
}

var xxx_messageInfo_IfaceAccess proto.InternalMessageInfo

type OpUnsupported struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *OpUnsupported) Reset()         { *m = OpUnsupported{} }
func (m *OpUnsupported) String() string { return proto.CompactTextString(m) }
func (*OpUnsupported) ProtoMessage()    {}
func (*OpUnsupported) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{6}
}
func (m *OpUnsupported) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpUnsupported) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpUnsupported.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OpUnsupported) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpUnsupported.Merge(dst, src)
}
func (m *OpUnsupported) XXX_Size() int {
	return m.Size()
}
func (m *OpUnsupported) XXX_DiscardUnknown() {
	xxx_messageInfo_OpUnsupported.DiscardUnknown(m)
}

var xxx_messageInfo_OpUnsupported proto.InternalMessageInfo

type ModuleList struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleList) Reset()         { *m = ModuleList{} }
func (m *ModuleList) String() string { return proto.CompactTextString(m) }
func (*ModuleList) ProtoMessage()    {}
func (*ModuleList) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{7}
}
func (m *ModuleList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleList.Merge(dst, src)
}
func (m *ModuleList) XXX_Size() int {
	return m.Size()
}
func (m *ModuleList) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleList.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleList proto.InternalMessageInfo

type ModuleUploadNew struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleUploadNew) Reset()         { *m = ModuleUploadNew{} }
func (m *ModuleUploadNew) String() string { return proto.CompactTextString(m) }
func (*ModuleUploadNew) ProtoMessage()    {}
func (*ModuleUploadNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{8}
}
func (m *ModuleUploadNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleUploadNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleUploadNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleUploadNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleUploadNew.Merge(dst, src)
}
func (m *ModuleUploadNew) XXX_Size() int {
	return m.Size()
}
func (m *ModuleUploadNew) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleUploadNew.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleUploadNew proto.InternalMessageInfo

type ModuleUploadExist struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Compiled             bool           `protobuf:"varint,3,opt,name=compiled,proto3" json:"compiled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleUploadExist) Reset()         { *m = ModuleUploadExist{} }
func (m *ModuleUploadExist) String() string { return proto.CompactTextString(m) }
func (*ModuleUploadExist) ProtoMessage()    {}
func (*ModuleUploadExist) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{9}
}
func (m *ModuleUploadExist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleUploadExist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleUploadExist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleUploadExist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleUploadExist.Merge(dst, src)
}
func (m *ModuleUploadExist) XXX_Size() int {
	return m.Size()
}
func (m *ModuleUploadExist) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleUploadExist.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleUploadExist proto.InternalMessageInfo

type ModuleSourceNew struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Uri                  string         `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleSourceNew) Reset()         { *m = ModuleSourceNew{} }
func (m *ModuleSourceNew) String() string { return proto.CompactTextString(m) }
func (*ModuleSourceNew) ProtoMessage()    {}
func (*ModuleSourceNew) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{10}
}
func (m *ModuleSourceNew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleSourceNew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleSourceNew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleSourceNew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleSourceNew.Merge(dst, src)
}
func (m *ModuleSourceNew) XXX_Size() int {
	return m.Size()
}
func (m *ModuleSourceNew) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleSourceNew.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleSourceNew proto.InternalMessageInfo

type ModuleSourceExist struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Uri                  string         `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	Compiled             bool           `protobuf:"varint,4,opt,name=compiled,proto3" json:"compiled,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleSourceExist) Reset()         { *m = ModuleSourceExist{} }
func (m *ModuleSourceExist) String() string { return proto.CompactTextString(m) }
func (*ModuleSourceExist) ProtoMessage()    {}
func (*ModuleSourceExist) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{11}
}
func (m *ModuleSourceExist) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleSourceExist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleSourceExist.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleSourceExist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleSourceExist.Merge(dst, src)
}
func (m *ModuleSourceExist) XXX_Size() int {
	return m.Size()
}
func (m *ModuleSourceExist) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleSourceExist.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleSourceExist proto.InternalMessageInfo

type ModuleDownload struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleDownload) Reset()         { *m = ModuleDownload{} }
func (m *ModuleDownload) String() string { return proto.CompactTextString(m) }
func (*ModuleDownload) ProtoMessage()    {}
func (*ModuleDownload) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{12}
}
func (m *ModuleDownload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleDownload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleDownload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleDownload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleDownload.Merge(dst, src)
}
func (m *ModuleDownload) XXX_Size() int {
	return m.Size()
}
func (m *ModuleDownload) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleDownload.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleDownload proto.InternalMessageInfo

type ModuleUnref struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Module               string         `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModuleUnref) Reset()         { *m = ModuleUnref{} }
func (m *ModuleUnref) String() string { return proto.CompactTextString(m) }
func (*ModuleUnref) ProtoMessage()    {}
func (*ModuleUnref) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{13}
}
func (m *ModuleUnref) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModuleUnref) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModuleUnref.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ModuleUnref) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModuleUnref.Merge(dst, src)
}
func (m *ModuleUnref) XXX_Size() int {
	return m.Size()
}
func (m *ModuleUnref) XXX_DiscardUnknown() {
	xxx_messageInfo_ModuleUnref.DiscardUnknown(m)
}

var xxx_messageInfo_ModuleUnref proto.InternalMessageInfo

type InstanceList struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceList) Reset()         { *m = InstanceList{} }
func (m *InstanceList) String() string { return proto.CompactTextString(m) }
func (*InstanceList) ProtoMessage()    {}
func (*InstanceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{14}
}
func (m *InstanceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceList.Merge(dst, src)
}
func (m *InstanceList) XXX_Size() int {
	return m.Size()
}
func (m *InstanceList) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceList.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceList proto.InternalMessageInfo

type InstanceCreateStream struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceCreateStream) Reset()         { *m = InstanceCreateStream{} }
func (m *InstanceCreateStream) String() string { return proto.CompactTextString(m) }
func (*InstanceCreateStream) ProtoMessage()    {}
func (*InstanceCreateStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{15}
}
func (m *InstanceCreateStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceCreateStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceCreateStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceCreateStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceCreateStream.Merge(dst, src)
}
func (m *InstanceCreateStream) XXX_Size() int {
	return m.Size()
}
func (m *InstanceCreateStream) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceCreateStream.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceCreateStream proto.InternalMessageInfo

type InstanceCreateLocal struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	Module               string         `protobuf:"bytes,3,opt,name=module,proto3" json:"module,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceCreateLocal) Reset()         { *m = InstanceCreateLocal{} }
func (m *InstanceCreateLocal) String() string { return proto.CompactTextString(m) }
func (*InstanceCreateLocal) ProtoMessage()    {}
func (*InstanceCreateLocal) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{16}
}
func (m *InstanceCreateLocal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceCreateLocal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceCreateLocal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceCreateLocal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceCreateLocal.Merge(dst, src)
}
func (m *InstanceCreateLocal) XXX_Size() int {
	return m.Size()
}
func (m *InstanceCreateLocal) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceCreateLocal.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceCreateLocal proto.InternalMessageInfo

type InstanceDelete struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceDelete) Reset()         { *m = InstanceDelete{} }
func (m *InstanceDelete) String() string { return proto.CompactTextString(m) }
func (*InstanceDelete) ProtoMessage()    {}
func (*InstanceDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{17}
}
func (m *InstanceDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceDelete.Merge(dst, src)
}
func (m *InstanceDelete) XXX_Size() int {
	return m.Size()
}
func (m *InstanceDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceDelete.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceDelete proto.InternalMessageInfo

type InstanceConnect struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceConnect) Reset()         { *m = InstanceConnect{} }
func (m *InstanceConnect) String() string { return proto.CompactTextString(m) }
func (*InstanceConnect) ProtoMessage()    {}
func (*InstanceConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{18}
}
func (m *InstanceConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceConnect.Merge(dst, src)
}
func (m *InstanceConnect) XXX_Size() int {
	return m.Size()
}
func (m *InstanceConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceConnect.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceConnect proto.InternalMessageInfo

type InstanceDisconnect struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceDisconnect) Reset()         { *m = InstanceDisconnect{} }
func (m *InstanceDisconnect) String() string { return proto.CompactTextString(m) }
func (*InstanceDisconnect) ProtoMessage()    {}
func (*InstanceDisconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{19}
}
func (m *InstanceDisconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceDisconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceDisconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceDisconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceDisconnect.Merge(dst, src)
}
func (m *InstanceDisconnect) XXX_Size() int {
	return m.Size()
}
func (m *InstanceDisconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceDisconnect.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceDisconnect proto.InternalMessageInfo

type InstanceStatus struct {
	Ctx                  detail.Context `protobuf:"bytes,1,opt,name=ctx" json:"ctx"`
	Instance             string         `protobuf:"bytes,2,opt,name=instance,proto3" json:"instance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceStatus) Reset()         { *m = InstanceStatus{} }
func (m *InstanceStatus) String() string { return proto.CompactTextString(m) }
func (*InstanceStatus) ProtoMessage()    {}
func (*InstanceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_event_f59d74c659a633cd, []int{20}
}
func (m *InstanceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InstanceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceStatus.Merge(dst, src)
}
func (m *InstanceStatus) XXX_Size() int {
	return m.Size()
}
func (m *InstanceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceStatus proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Event)(nil), "event.Event")
	proto.RegisterType((*FailInternal)(nil), "event.FailInternal")
	proto.RegisterType((*FailNetwork)(nil), "event.FailNetwork")
	proto.RegisterType((*FailProtocol)(nil), "event.FailProtocol")
	proto.RegisterType((*FailRequest)(nil), "event.FailRequest")
	proto.RegisterType((*IfaceAccess)(nil), "event.IfaceAccess")
	proto.RegisterType((*OpUnsupported)(nil), "event.OpUnsupported")
	proto.RegisterType((*ModuleList)(nil), "event.ModuleList")
	proto.RegisterType((*ModuleUploadNew)(nil), "event.ModuleUploadNew")
	proto.RegisterType((*ModuleUploadExist)(nil), "event.ModuleUploadExist")
	proto.RegisterType((*ModuleSourceNew)(nil), "event.ModuleSourceNew")
	proto.RegisterType((*ModuleSourceExist)(nil), "event.ModuleSourceExist")
	proto.RegisterType((*ModuleDownload)(nil), "event.ModuleDownload")
	proto.RegisterType((*ModuleUnref)(nil), "event.ModuleUnref")
	proto.RegisterType((*InstanceList)(nil), "event.InstanceList")
	proto.RegisterType((*InstanceCreateStream)(nil), "event.InstanceCreateStream")
	proto.RegisterType((*InstanceCreateLocal)(nil), "event.InstanceCreateLocal")
	proto.RegisterType((*InstanceDelete)(nil), "event.InstanceDelete")
	proto.RegisterType((*InstanceConnect)(nil), "event.InstanceConnect")
	proto.RegisterType((*InstanceDisconnect)(nil), "event.InstanceDisconnect")
	proto.RegisterType((*InstanceStatus)(nil), "event.InstanceStatus")
	proto.RegisterEnum("event.Event_Type", Event_Type_name, Event_Type_value)
	proto.RegisterEnum("event.FailRequest_Type", FailRequest_Type_name, FailRequest_Type_value)
}
func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FailInternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailInternal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n1, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Source) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Function) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Function)))
		i += copy(dAtA[i:], m.Function)
	}
	if len(m.Instance) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Subsystem) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Subsystem)))
		i += copy(dAtA[i:], m.Subsystem)
	}
	return i, nil
}

func (m *FailNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n2, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *FailProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailProtocol) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n3, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *FailRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n4, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.Failure != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEvent(dAtA, i, uint64(m.Failure))
	}
	if len(m.Source) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Function) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Function)))
		i += copy(dAtA[i:], m.Function)
	}
	if len(m.Instance) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *IfaceAccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IfaceAccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n5, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *OpUnsupported) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpUnsupported) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n6, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	return i, nil
}

func (m *ModuleList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n7, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *ModuleUploadNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleUploadNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n8, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *ModuleUploadExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleUploadExist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n9, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if m.Compiled {
		dAtA[i] = 0x18
		i++
		if m.Compiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ModuleSourceNew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSourceNew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n10, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	return i, nil
}

func (m *ModuleSourceExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleSourceExist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n11, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Compiled {
		dAtA[i] = 0x20
		i++
		if m.Compiled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ModuleDownload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleDownload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n12, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *ModuleUnref) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModuleUnref) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n13, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if len(m.Module) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *InstanceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n14, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *InstanceCreateStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCreateStream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n15, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *InstanceCreateLocal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCreateLocal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n16, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	if len(m.Module) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	return i, nil
}

func (m *InstanceDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n17, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n18, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceDisconnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n19, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func (m *InstanceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEvent(dAtA, i, uint64(m.Ctx.Size()))
	n20, err := m.Ctx.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if len(m.Instance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Instance)))
		i += copy(dAtA[i:], m.Instance)
	}
	return i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Event) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FailInternal) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Function)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Subsystem)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *FailNetwork) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *FailProtocol) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *FailRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	if m.Failure != 0 {
		n += 1 + sovEvent(uint64(m.Failure))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Function)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *IfaceAccess) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *OpUnsupported) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *ModuleList) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *ModuleUploadNew) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ModuleUploadExist) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Compiled {
		n += 2
	}
	return n
}

func (m *ModuleSourceNew) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ModuleSourceExist) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Compiled {
		n += 2
	}
	return n
}

func (m *ModuleDownload) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *ModuleUnref) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceList) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *InstanceCreateStream) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceCreateLocal) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceDelete) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceConnect) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceDisconnect) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *InstanceStatus) Size() (n int) {
	var l int
	_ = l
	l = m.Ctx.Size()
	n += 1 + l + sovEvent(uint64(l))
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func sovEvent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailInternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailInternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailInternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Function = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subsystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subsystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			m.Failure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Failure |= (FailRequest_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Function = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IfaceAccess) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IfaceAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IfaceAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpUnsupported) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpUnsupported: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpUnsupported: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleUploadNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleUploadNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleUploadNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleUploadExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleUploadExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleUploadExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compiled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSourceNew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleSourceNew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleSourceNew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleSourceExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleSourceExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleSourceExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compiled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compiled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleDownload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleDownload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleDownload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModuleUnref) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModuleUnref: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModuleUnref: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCreateStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCreateStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCreateStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCreateLocal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCreateLocal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCreateLocal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceConnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEvent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEvent(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEvent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("server/event/event.proto", fileDescriptor_event_f59d74c659a633cd) }

var fileDescriptor_event_f59d74c659a633cd = []byte{
	// 883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4f, 0x6f, 0x23, 0x35,
	0x14, 0xcf, 0x34, 0x7f, 0xda, 0x3a, 0x4d, 0xe2, 0xba, 0xcb, 0x6e, 0x54, 0xa1, 0xb0, 0x1a, 0x21,
	0xb1, 0xa7, 0x54, 0x2c, 0x82, 0x45, 0xdc, 0x76, 0xb7, 0xad, 0x88, 0xe8, 0x86, 0x32, 0x25, 0x48,
	0x70, 0x73, 0x3d, 0x2f, 0xad, 0xc5, 0xc4, 0x1e, 0x6c, 0x4f, 0xff, 0x5c, 0x11, 0x07, 0x4e, 0x88,
	0x2f, 0xc4, 0xbd, 0x47, 0x3e, 0x00, 0x42, 0x50, 0xbe, 0x08, 0xf2, 0x78, 0x26, 0x99, 0x49, 0x53,
	0x14, 0xd4, 0xec, 0xa5, 0xcd, 0xfb, 0xf9, 0xe7, 0x67, 0xbf, 0x37, 0xef, 0xf7, 0x9e, 0x51, 0x57,
	0x83, 0xba, 0x00, 0xb5, 0x07, 0x17, 0x20, 0x8c, 0xfb, 0xdb, 0x8f, 0x95, 0x34, 0x92, 0xd4, 0x53,
	0x63, 0x77, 0x37, 0x23, 0x84, 0x60, 0x28, 0x8f, 0xb2, 0x7f, 0x8e, 0xe2, 0xff, 0x52, 0x45, 0xf5,
	0x03, 0xcb, 0xf2, 0x7f, 0xaa, 0xa2, 0xda, 0xd7, 0xd7, 0x31, 0x10, 0x8c, 0xb6, 0x0e, 0x29, 0x8f,
	0x06, 0xc2, 0x80, 0x12, 0x34, 0xc2, 0x15, 0xd2, 0x41, 0x4d, 0x8b, 0x0c, 0xc1, 0x5c, 0x4a, 0xf5,
	0x3d, 0xf6, 0x72, 0xca, 0xb1, 0x75, 0xc1, 0x64, 0x84, 0xd7, 0x72, 0x4a, 0x00, 0x3f, 0x24, 0xa0,
	0x0d, 0xae, 0x5a, 0x60, 0x30, 0xa6, 0x0c, 0x5e, 0x32, 0x06, 0x5a, 0xe3, 0x1a, 0x69, 0x23, 0xf4,
	0x46, 0x86, 0x49, 0x04, 0x47, 0x5c, 0x1b, 0x5c, 0x27, 0x3b, 0xa8, 0xe3, 0xec, 0x51, 0x1c, 0x49,
	0x1a, 0x0e, 0xe1, 0x12, 0x37, 0xc8, 0x3b, 0x68, 0xbb, 0x08, 0x1e, 0x5c, 0x59, 0xee, 0xfa, 0x8c,
	0x7b, 0x22, 0x13, 0xc5, 0xc0, 0x72, 0x37, 0x66, 0x5c, 0x07, 0x3a, 0xee, 0x26, 0x21, 0xa8, 0xed,
	0xe0, 0x7d, 0x79, 0x29, 0xac, 0x13, 0x8c, 0xec, 0x65, 0x32, 0xb7, 0x42, 0xc1, 0x18, 0x37, 0x6d,
	0x00, 0x03, 0xa1, 0x0d, 0x15, 0xcc, 0x5d, 0x67, 0x8b, 0x74, 0xd1, 0xa3, 0x1c, 0x79, 0xad, 0x80,
	0x1a, 0x38, 0x31, 0x0a, 0xe8, 0x04, 0xb7, 0xc8, 0x13, 0xb4, 0x53, 0x5e, 0x39, 0x92, 0x8c, 0x46,
	0xb8, 0x6d, 0x4f, 0xca, 0x17, 0xf6, 0x21, 0x02, 0x03, 0xb8, 0x63, 0x6f, 0x3a, 0x25, 0x4b, 0x21,
	0x80, 0x19, 0x8c, 0xc9, 0x63, 0x44, 0xa6, 0x44, 0xae, 0x59, 0x86, 0x6f, 0x17, 0x1d, 0x9c, 0x18,
	0x6a, 0x12, 0x8d, 0x89, 0xff, 0x9b, 0x57, 0x4e, 0x3f, 0xf9, 0x00, 0x55, 0x99, 0xb9, 0xea, 0x7a,
	0x4f, 0xbd, 0x67, 0xcd, 0xe7, 0x9d, 0x7e, 0xf6, 0xf5, 0x5e, 0x4b, 0x61, 0xe0, 0xca, 0xbc, 0xaa,
	0xdd, 0xfc, 0xf9, 0x5e, 0x25, 0xb0, 0x0c, 0xf2, 0x18, 0x35, 0x74, 0x9a, 0x89, 0xee, 0xda, 0x53,
	0xef, 0xd9, 0x66, 0x90, 0x59, 0x16, 0x9f, 0xa4, 0xc1, 0x77, 0xab, 0x0e, 0x77, 0x16, 0xd9, 0x45,
	0x1b, 0xe3, 0x44, 0x30, 0xc3, 0xa5, 0xe8, 0xd6, 0xd2, 0x95, 0xa9, 0x6d, 0xd7, 0x78, 0x76, 0xb3,
	0x6e, 0xdd, 0xad, 0xe5, 0x36, 0x79, 0x17, 0x6d, 0xea, 0xe4, 0x54, 0x5f, 0x6b, 0x03, 0x93, 0x6e,
	0x23, 0x5d, 0x9c, 0x01, 0xfe, 0x27, 0xa5, 0x5a, 0x59, 0xfa, 0xf6, 0xfe, 0x8b, 0x72, 0x49, 0x2d,
	0xbf, 0xf1, 0x8f, 0x5a, 0xa9, 0xf4, 0x96, 0xcf, 0xd7, 0x87, 0x68, 0x7d, 0x4c, 0x79, 0x94, 0x28,
	0x97, 0xb0, 0xf6, 0xf3, 0x27, 0x7d, 0x27, 0x9e, 0x82, 0xb7, 0xbe, 0x55, 0x44, 0x90, 0xf3, 0x0a,
	0x29, 0xae, 0xde, 0x93, 0xe2, 0xda, 0xbd, 0x29, 0xae, 0xff, 0x47, 0x8a, 0x1b, 0xe5, 0x14, 0xfb,
	0x3f, 0xe7, 0x5a, 0xec, 0xa0, 0xe6, 0x48, 0xe8, 0x18, 0x18, 0x1f, 0x73, 0x08, 0x71, 0xc5, 0x16,
	0xee, 0x31, 0xbd, 0x4e, 0xb5, 0xa1, 0x94, 0x54, 0xd8, 0xb3, 0x32, 0x38, 0x56, 0x5c, 0x30, 0x1e,
	0xd3, 0xe8, 0x0b, 0xb8, 0x76, 0x70, 0x2a, 0xc8, 0x97, 0x89, 0x39, 0x7f, 0xc3, 0xb5, 0xe6, 0xe2,
	0xcc, 0x09, 0xd2, 0x02, 0x03, 0x71, 0x41, 0x23, 0x1e, 0xe2, 0x5a, 0x0e, 0x1c, 0x5c, 0xc5, 0x5c,
	0x41, 0x88, 0xeb, 0x56, 0xa1, 0x16, 0x08, 0x20, 0xd1, 0x10, 0xe2, 0x46, 0x6e, 0xef, 0x83, 0xb0,
	0x67, 0xaf, 0xdb, 0x72, 0x0d, 0xc0, 0x45, 0x9c, 0x61, 0x1b, 0x64, 0x1b, 0xb5, 0x72, 0xec, 0x88,
	0x4f, 0xb8, 0x15, 0x60, 0x0b, 0x6d, 0x06, 0x56, 0x25, 0xa9, 0x89, 0x66, 0x7a, 0x1c, 0x4a, 0x73,
	0x28, 0x13, 0x11, 0xe2, 0xa6, 0x15, 0x84, 0xc3, 0x3e, 0xa7, 0xda, 0x5e, 0x71, 0x42, 0x0d, 0x3b,
	0xc7, 0x5b, 0x33, 0x9d, 0xba, 0x28, 0x5a, 0xe4, 0x11, 0xc2, 0x87, 0x59, 0xc2, 0xa6, 0xdb, 0xdb,
	0x69, 0x12, 0x94, 0x3c, 0x53, 0x74, 0xe2, 0x78, 0x1d, 0xcb, 0xcb, 0x95, 0x34, 0xe5, 0x61, 0x9b,
	0x9a, 0x1c, 0x1d, 0x84, 0x79, 0xe0, 0xdb, 0x45, 0xf2, 0xc0, 0xb5, 0x18, 0x8d, 0x49, 0x91, 0x3c,
	0x94, 0xb9, 0x76, 0x77, 0x6c, 0x3d, 0x17, 0xfa, 0xd8, 0xf2, 0x65, 0xf9, 0x29, 0x6a, 0x7d, 0x19,
	0x8f, 0x84, 0x4e, 0xe2, 0x58, 0x2a, 0x03, 0xe1, 0xf2, 0x3b, 0x3f, 0x2e, 0x36, 0xca, 0xe5, 0xb7,
	0x05, 0x77, 0xfa, 0xe9, 0xff, 0x6a, 0x1d, 0x59, 0xfd, 0xae, 0x15, 0xeb, 0xd7, 0x8f, 0x17, 0xb4,
	0xe3, 0x07, 0x7b, 0xb5, 0x95, 0xcf, 0xe4, 0x24, 0xe6, 0x11, 0x84, 0xa9, 0x8e, 0x36, 0x82, 0xa9,
	0xed, 0x87, 0x77, 0x3a, 0xfd, 0xc3, 0xcf, 0xc3, 0xa8, 0x9a, 0x28, 0x9e, 0x49, 0xd6, 0xfe, 0xf4,
	0x7f, 0xf4, 0x16, 0xcc, 0x8e, 0xb7, 0x70, 0x50, 0x29, 0xd4, 0xda, 0x5c, 0xa8, 0x5f, 0xcd, 0x0f,
	0xaa, 0x87, 0x7f, 0xaf, 0x61, 0x69, 0xce, 0x3d, 0xdc, 0xdf, 0x8b, 0xf2, 0x98, 0x5c, 0xbe, 0x18,
	0xf5, 0xe2, 0x69, 0xba, 0xfc, 0x8d, 0x8a, 0xdd, 0x71, 0x6d, 0x6e, 0x00, 0xdd, 0x33, 0xd0, 0x7c,
	0xb5, 0x70, 0x50, 0xbf, 0xdd, 0x33, 0x47, 0xf3, 0x6f, 0x80, 0x95, 0x1c, 0xe7, 0x7f, 0x73, 0xe7,
	0x19, 0xb1, 0x1a, 0xbf, 0xdf, 0x2e, 0x7a, 0x89, 0xac, 0xc6, 0xf5, 0x68, 0xfe, 0x31, 0xb3, 0x12,
	0xb7, 0xaf, 0x3e, 0xbb, 0xf9, 0xbb, 0x57, 0xb9, 0xb9, 0xed, 0x79, 0xbf, 0xdf, 0xf6, 0xbc, 0xbf,
	0x6e, 0x7b, 0xde, 0xaf, 0xff, 0xf4, 0x2a, 0xdf, 0xbd, 0x7f, 0xc6, 0xcd, 0x79, 0x72, 0xda, 0x67,
	0x72, 0xb2, 0x67, 0x34, 0xbd, 0x90, 0x11, 0xdd, 0x3b, 0xa3, 0x06, 0xf6, 0x8a, 0x6f, 0xe1, 0xd3,
	0x46, 0xfa, 0xc6, 0xfd, 0xe8, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x44, 0xce, 0xb3, 0x8a, 0x22,
	0x0b, 0x00, 0x00,
}
